<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>学无止境</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="学无止境">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="学无止境">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学无止境">
  
    <link rel="alternate" href="/atom.xml" title="学无止境" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">学无止境</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-面试问题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/10/面试问题总结/" class="article-date">
  <time datetime="2019-10-10T01:32:48.000Z" itemprop="datePublished">2019-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/10/面试问题总结/">面试问题总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、原生js基础相关"><a href="#一、原生js基础相关" class="headerlink" title="一、原生js基础相关"></a>一、原生js基础相关</h2><h4 id="变量区分大小写"><a href="#变量区分大小写" class="headerlink" title="变量区分大小写"></a>变量区分大小写</h4><h4 id="1、数据类型有哪些"><a href="#1、数据类型有哪些" class="headerlink" title="1、数据类型有哪些"></a>1、数据类型有哪些</h4><pre><code>基本数据类型(存放在栈中)：string、number、boolean、null、undefined、symbol
引用类型(存放在堆中)：object、function
</code></pre><p><strong>注意1:</strong> 栈和堆的区别<br>    栈（stack）为自动分配的内存空间, 它由系统自动释放; 而堆（heap）则是动态分配的内存, 大小不定也不会自动释放<br><strong>注意2:</strong> null和undefined的区别<br>    typeof undefined   // undefined<br>    typeof null        // object<br>    null === undefined // false<br>    null == undefined  // true</p>
<h4 id="2、如何判断数据的类型"><a href="#2、如何判断数据的类型" class="headerlink" title="2、如何判断数据的类型"></a>2、如何判断数据的类型</h4><pre><code>typeof 可以正确的判断基本数据类型的类型, 但是对于对象, 都是object, 对于函数都是function
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof [] === <span class="string">'object'</span></span><br><span class="line">typeof &#123;&#125; === <span class="string">'object'</span></span><br><span class="line">typeof alert === <span class="string">'function'</span></span><br><span class="line">typeof null === <span class="string">'object'</span> (一个存在很久的bug)</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="3、判断是不是某构造函数的实例"><a href="#3、判断是不是某构造函数的实例" class="headerlink" title="3、判断是不是某构造函数的实例"></a>3、判断是不是某构造函数的实例</h4><pre><code>instanceof：通过原型链判断
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person (name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> p1 = new Person(<span class="string">'张三'</span>)</span><br><span class="line">p1 instanceof Person // <span class="literal">true</span> p1是构造函数Person的实例</span><br><span class="line">Person[Symbol.hasInstance](p1) // <span class="literal">true</span> 与上面等价</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="4、等号赋值、浅拷贝、深拷贝的区别"><a href="#4、等号赋值、浅拷贝、深拷贝的区别" class="headerlink" title="4、等号赋值、浅拷贝、深拷贝的区别"></a>4、等号赋值、浅拷贝、深拷贝的区别</h4><p><a href="https://www.haorooms.com/post/js_copy_sq" target="_blank" rel="noopener">https://www.haorooms.com/post/js_copy_sq</a><br>等号赋值：新数据和原数据指向同一引用<br>浅拷贝：新数据和原数据不指向同一个引用, 如果原数据里包含子对象, 新旧子对象共享同一块内存<br>深拷贝：会另外创造一个一模一样的对象, 新对象跟原对象不共享内存, 修改新对象不会改到原对象<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####浅拷贝的实现方式:</span></span><br><span class="line"></span><br><span class="line">第一种：lodash的方法_.cclone</span><br><span class="line">第二种：... </span><br><span class="line">第三种：Object.assgin(), 注意：obj里必须含有子对象</span><br><span class="line">var obj = &#123; a: &#123;msg: <span class="string">"hello"</span>, num: 21&#125;, b:3 &#125;;</span><br><span class="line">var cloneObj = Object.assign(&#123;&#125;, obj);</span><br><span class="line">obj === cloneObj; // <span class="literal">false</span></span><br><span class="line">obj.a.num = 66;</span><br><span class="line">obj.b = 10;</span><br><span class="line">console.log(cloneObj.a.num); // 66</span><br><span class="line">console.log(cloneObj.b); // 3</span><br><span class="line">第四种：自定义方法</span><br><span class="line"><span class="keyword">function</span> shallowClone(initalObj) &#123;    </span><br><span class="line">    var obj = &#123;&#125;;    </span><br><span class="line">    <span class="keyword">for</span> ( var i <span class="keyword">in</span> initalObj) &#123;</span><br><span class="line">        obj[i] = initalObj[i];</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: <span class="string">"hello"</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        a: <span class="string">"world"</span>,</span><br><span class="line">        b: 21</span><br><span class="line">    &#125;,</span><br><span class="line">    c: [<span class="string">"Bob"</span>, <span class="string">"Tom"</span>, <span class="string">"Jenny"</span>],</span><br><span class="line">    d: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        alert(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var cloneObj = shallowClone(obj); </span><br><span class="line">cloneObj === obj; // <span class="literal">false</span></span><br><span class="line">// 新数据和原数据的b、c、d指向同一引用</span><br><span class="line">cloneObj.b.a = <span class="string">"changed"</span>; // obj和cloneObj都改变</span><br><span class="line">cloneObj.c[0] = 6; // obj和cloneObj都改变</span><br><span class="line">cloneObj.d = <span class="function"><span class="title">function</span></span>() &#123; alert(<span class="string">"changed"</span>); &#125; // obj的d属性不改变</span><br><span class="line"></span><br><span class="line"><span class="comment">#####深拷贝的实现方式:</span></span><br><span class="line">第一种：用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象</span><br><span class="line">第二种：对象只有一层的话可以使用上面的：Object.assign()函数</span><br><span class="line">第三种：自定义方法，递归拷贝</span><br><span class="line">第四种：lodash的_.cloneDeep</span><br></pre></td></tr></table></figure></p>
<h4 id="5、什么是闭包-闭包的作用-为什么要使用闭包"><a href="#5、什么是闭包-闭包的作用-为什么要使用闭包" class="headerlink" title="5、什么是闭包, 闭包的作用, 为什么要使用闭包"></a>5、什么是闭包, 闭包的作用, 为什么要使用闭包</h4><pre><code>匿名函数本身也是一个闭包
闭包：函数A里面有一个函数B, 函数B可以访问到函数A里面的局部变量, 函数B就是闭包
本质：闭包是将函数内部和函数外部连接起来的桥梁
作用：1、可以读取函数内部的变量 2、让一些变量始终保持在内存中
为什么要使用闭包：在函数外部无法读取函数内部的局部变量, 如果想要获取, 可以在函数里在声明一个函数
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 想要在函数外部获取f1里面的变量n, 所以需要在f1里声明一个f2, 并作为返回值</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">    var n = 999;</span><br><span class="line">    nAdd = <span class="function"><span class="title">function</span></span>() &#123;n += 1&#125;; // 没用var声明, 则是全局变量</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>()&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> f2; // f2就是闭包</span><br><span class="line">&#125;</span><br><span class="line">var result = f1();</span><br><span class="line">result(); // 999</span><br><span class="line">nAdd();</span><br><span class="line">result(); // 1000</span><br></pre></td></tr></table></figure>
<p>1、首先函数f1执行后将f2赋给了全局变量result，所以f2始终在内存中，函数f2在函数f1内部，所以在f2的内部可以访问到f1的变量n。<br>2、因为f2的存在依赖了f1中的变量n，所以使得f1也始终被存储在了内存中，在调用之后，不会被垃圾回收机制回收。（内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被释放,因为闭包需要它们）</p>
<h4 id="6、构造函数和继承"><a href="#6、构造函数和继承" class="headerlink" title="6、构造函数和继承"></a>6、构造函数和继承</h4><pre><code>A为父类, 在子类B的构造函数里调用父类的构造函数，子类的原型指向父类的实例
实例化new 的过程中会发生以上四件事情：
    a、新生成了一个对象
    b、链接到原型
    c、绑定 this
    d、返回新对象
</code></pre><h4 id="7、什么是原型？什么是原型链"><a href="#7、什么是原型？什么是原型链" class="headerlink" title="7、什么是原型？什么是原型链"></a>7、什么是原型？什么是原型链</h4><pre><code>构造函数的prototype属性指向原型,原型的constructor属性指回构造函数,实例的_proto_指向原型。
所有实例共享原型上的属性和方法
</code></pre><h4 id="8、浏览器端缓存"><a href="#8、浏览器端缓存" class="headerlink" title="8、浏览器端缓存"></a>8、浏览器端缓存</h4><pre><code>cookie：与服务器端通信,每次都会携带在HTTP头中。cookie的长度和数量受限制,每个domain最多只能有20条cookie,每个cookie长度不能超过4KB。否则会被截掉。
sessionStorage: 仅在当前会话下有效,关闭页面或浏览器后被清除,存放数据大小为一般为5MB,在客户端中保存,不参与和服务器的通信
localStorage：存放数据大小为一般为5MB,在客户端中保存,不参与和服务器的通信
</code></pre><h4 id="9、同步和异步、并发和并行、线程和多线程和单线程、进程"><a href="#9、同步和异步、并发和并行、线程和多线程和单线程、进程" class="headerlink" title="9、同步和异步、并发和并行、线程和多线程和单线程、进程"></a>9、同步和异步、并发和并行、线程和多线程和单线程、进程</h4><pre><code>并行: 同一时刻发生两个或者多个事件。比如：并行：你吃饭吃到一半, 电话来了, 你一边打电话一边吃饭
并发: 同一时科两个或多个事件在间隔发生。比如：你吃饭吃到一半, 电话来了, 你停了下来接了电话, 接完后继续吃饭

进程: 当一个程序开始运行时, 它就是一个进程, 一个进程又是由多个线程所组成的
多线程: 一个程序中可以同时运行多个不同的线程
单线程: 一个程序中只有一个线程

同步：A请求回来了再发B请求
异步：A请求和B请求可以同时发
</code></pre><h4 id="10、for循环有哪些方法及区别"><a href="#10、for循环有哪些方法及区别" class="headerlink" title="10、for循环有哪些方法及区别"></a>10、for循环有哪些方法及区别</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [2,4,1,5,7]</span><br><span class="line">arr.length= 5</span><br><span class="line"><span class="built_in">let</span> obj = &#123;name: <span class="string">'张三'</span>, age: 12&#125;</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'abcdefg123'</span></span><br><span class="line">// 支持数组、字符串</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i=0;i&lt;=str.length-1;i++) &#123;</span><br><span class="line">    console.log(i, arr[i]) // i是索引</span><br><span class="line">&#125;</span><br><span class="line">//  支持数组、字符串、对象</span><br><span class="line">// 缺点(针对数组)：可以将属性打印出来</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    console.log(i, arr[i]) // i是索引0,1,2,3,4,length</span><br><span class="line">&#125;</span><br><span class="line">//  支持数组、字符串(es6提出,解决<span class="keyword">for</span>-in的缺陷, 只返回具有数字索引的属性)</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of arr) &#123;</span><br><span class="line">    console.log(value) // value 是值, 不是索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、箭头函数和普通函数的this指向"><a href="#11、箭头函数和普通函数的this指向" class="headerlink" title="11、箭头函数和普通函数的this指向"></a>11、箭头函数和普通函数的this指向</h4><pre><code>箭头函数：如果包裹在函数中, 只取决包裹箭头函数的第一个普通函数的this
普通函数：this由函数调用时决定
</code></pre><h4 id="12、break、continue、return的区别"><a href="#12、break、continue、return的区别" class="headerlink" title="12、break、continue、return的区别"></a>12、break、continue、return的区别</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myBreak</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(var j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">        console.log(<span class="string">'j'</span>, j)</span><br><span class="line">        <span class="keyword">for</span>(var i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == 2) &#123;</span><br><span class="line">                <span class="built_in">break</span>; // j:0,i:0,i:1;j:1,i:0,i:1;j:2,i:0,i:1</span><br><span class="line">                <span class="built_in">continue</span>; // j:0,i:0,i:1,i:3;j:1,i:0,i:1,i:3;j:2,i:0,i:1,i:3</span><br><span class="line">                <span class="built_in">return</span>; // j:0,i:0,i:1</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(<span class="string">'i'</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myBreak();</span><br></pre></td></tr></table></figure>
<pre><code>break: 跳出当前循环(如果嵌套多层循环, 只能跳出当前一层循环)
continue: 用于跳过当次循环, 还会继续循环
return: 结束函数的调用
</code></pre><h4 id="13、forEach、map、filter的区别"><a href="#13、forEach、map、filter的区别" class="headerlink" title="13、forEach、map、filter的区别"></a>13、forEach、map、filter的区别</h4><pre><code>forEach: 只是简单的将数组遍历, 不会改变原数组, 没有返回值
map: 方法里有return的话, 会返回新数组, 不会改变原数组; 也可以直接处理每一项的值, 会改变原数组 
filter: 使用return, 返回满足条件的新数组, 不会改变原数组
</code></pre><h4 id="14、字符串、数组、数字有哪些方法"><a href="#14、字符串、数组、数字有哪些方法" class="headerlink" title="14、字符串、数组、数字有哪些方法"></a>14、字符串、数组、数字有哪些方法</h4><pre><code>String对象方法：concat、indexOf、lastIndexOf、split、slice、substring、substr、toLowerCase、toUpperCase、trim、replace、toString、valueOf
Array对象方法：concat、join、indexOf、lastIndexOf、slice、splice、push、pop、shift、unshift、reverse、includes、reduce、find、findIndex、map、filter、forEach、some、isArray、sort、toString、valueOf
Number对象方法：toFixed、toString、valueOf
Boolean 对象方法：toString、valueOf
注意数组的sort方法:
sort()并不是按照数值进行排序，而是按字符串字母的ASCII码值进行比较排序的，所以当数组项为数字时，sort()也会自动先将数字转换成字符串，然后再按字母比较的规则进行排序处理。
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [8, 70, 16, 50, 6, 100, 1];</span><br><span class="line"><span class="keyword">function</span> compare (a, b) &#123;</span><br><span class="line">    console.log(a, b)</span><br><span class="line">    <span class="built_in">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> result = arr.sort(compare)</span><br><span class="line">console.log(<span class="string">'result'</span>, result) // 升序： [1, 6, 8, 16, 50, 70, 100]</span><br></pre></td></tr></table></figure>
<h4 id="15、什么是对象-面向对象和面向过程的区别"><a href="#15、什么是对象-面向对象和面向过程的区别" class="headerlink" title="15、什么是对象, 面向对象和面向过程的区别"></a>15、什么是对象, 面向对象和面向过程的区别</h4><pre><code>对象：拥有属性和方法的集合。在js里一切皆对象, 小轿车就是一个对象, 拥有轮胎、窗等属性, 方法有启动停止等
面向对象：封装, 继承, 多态的特点。碰到相同的问题可以直接调用
面向过程：分析出解决问题所需要的步骤, 然后用函数把这些步骤一步一步实现
举例：洗碗
面向过程：先把碗放到水池里 -&gt; 放水 -&gt; 倒洗洁精 -&gt; 用抹布洗 -&gt; 冲洗 -&gt; 拿出来晾干
面向对象：封装一个洗碗机
</code></pre><h4 id="16、长连接"><a href="#16、长连接" class="headerlink" title="16、长连接"></a>16、长连接</h4><pre><code>websocket：服务端主动向客户端推送消息
</code></pre><h4 id="17、js的三种类型转换"><a href="#17、js的三种类型转换" class="headerlink" title="17、js的三种类型转换"></a>17、js的三种类型转换</h4><pre><code>转换为布尔值、转换为数字、转换为字符串
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">原始值值类型</th>
<th style="text-align:left">转换目标</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left">除了’’, 其余都是true</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left">除了0、-0、NaN, 其余都是true</td>
</tr>
<tr>
<td style="text-align:left">null、undefined</td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">number、symbol</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">5 =&gt; ‘5’、String(Symbol()) =&gt; “Symbol()”</td>
</tr>
<tr>
<td style="text-align:left">function</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">String(function getName () {}) =&gt; “function getName () {}”</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">true =&gt; ‘true’、false =&gt; ‘false’</td>
</tr>
<tr>
<td style="text-align:left">数组</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">[] =&gt; ‘’、[1, 2] =&gt; ‘1,2’</td>
</tr>
<tr>
<td style="text-align:left">对象</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">“[object Object]”</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">‘’ =&gt; 0、’1’ =&gt; 1、’2sdsd’ =&gt; NaN</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">false =&gt; 0、true =&gt; 1</td>
</tr>
<tr>
<td style="text-align:left">数组</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">[] =&gt; 0、[1] =&gt; 1、[1,2] =&gt; NaN</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">undefined、除了数组的引用类型</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">NaN</td>
</tr>
<tr>
<td style="text-align:left">symbol</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">报错</td>
</tr>
</tbody>
</table>
<h4 id="18、浅比较和深比较的区别"><a href="#18、浅比较和深比较的区别" class="headerlink" title="18、浅比较和深比较的区别"></a>18、浅比较和深比较的区别</h4><p>浅比较：判断2个对象的引用地址是否一样<br>深比较：判断2个对象的所有属性值是否一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 浅比较</span><br><span class="line">const obj1 = &#123;age: 12&#125;</span><br><span class="line">const obj2 = &#123;age: 12&#125;</span><br><span class="line">const obj3 = obj1</span><br><span class="line">obj1 === obj2; // <span class="literal">false</span></span><br><span class="line">obj3 === obj1; // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="19、栈、堆、队列"><a href="#19、栈、堆、队列" class="headerlink" title="19、栈、堆、队列"></a>19、栈、堆、队列</h4><p>栈: 先进后出的有序集合，js的基本数据类型都存放在栈中，栈由编译器自动分配释放，调用完毕自动释放。<br>堆：一般由操作人员（程序员）分配释放，若操作人员不分配释放，将由OS回收释放，js的引用数据类型都存放在栈中<br>队列：先进先出的有序集合<br><strong>为什么会有堆内存、栈内存之分？</strong><br>通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。<br>当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；<br>当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。</p>
<h4 id="20、JavaScript-运行机制"><a href="#20、JavaScript-运行机制" class="headerlink" title="20、JavaScript 运行机制"></a>20、JavaScript 运行机制</h4><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" title="阮一峰" target="_blank" rel="noopener">参考文献</a></p>
<p><strong>宏任务、微任务</strong><br>宏任务：可以理解是每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)。主要场景有：主代码块、setTimeout、setInterval等<br>微任务：可以理解是在当前task执行结束后立即执行的任务。主要场景有：Promise、process.nextTick等。<br><strong>运行机制</strong><br>js是单线程，分为同步任务和异步任务<br>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。(事件循环)<br>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>
<h2 id="二、ajax请求相关"><a href="#二、ajax请求相关" class="headerlink" title="二、ajax请求相关"></a>二、ajax请求相关</h2><h4 id="1、post和get的区别"><a href="#1、post和get的区别" class="headerlink" title="1、post和get的区别"></a>1、post和get的区别</h4><pre><code>post：url在body体中, url长度限制是特定的浏览器及服务器对它的限制
get：参数拼接在url上, 出于安全考虑, 服务器端在实现时会做一定限制, nginix默认限制1M, Tomcat 默认是2M
</code></pre><p><strong>注意1:</strong> HTTP 协议规范没有对 get和post的URL 长度进行限制<br><strong>注意2:</strong> 不同浏览器对url长度的限制<br>IE: 2803<br>Firefox: 65536<br>Chrome: 8182<br>Safari: 80000<br>Opera: 190000</p>
<h4 id="2、什么是跨域-跨域有哪些解决方法"><a href="#2、什么是跨域-跨域有哪些解决方法" class="headerlink" title="2、什么是跨域, 跨域有哪些解决方法"></a>2、什么是跨域, 跨域有哪些解决方法</h4><pre><code>跨域：协议、ip、端口号 有一个不一样就是跨域
解决方案：
1、postMessage进行信息传递, HTML5的新api, 可以在不同的iframe之间传递消息
2、CORS：只需服务端设置Access-Control-Allow-Origin即可, 若要带cookie请求, 前后端都需要设置
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加<span class="string">'/'</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://www.domain1.com"</span>); </span><br><span class="line">// 允许前端带认证cookie：启用此项后，上面的域名不能为<span class="string">'*'</span>，必须指定具体的域名，否则浏览器会提示</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>); </span><br><span class="line">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type,X-Requested-With"</span>);</span><br></pre></td></tr></table></figure>
<pre><code>3、JSONP, 借助script标签
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 请求地址后面加一个callback=函数名, 后台返回 函数名(<span class="string">'我请求到了'</span>), 就能调用到该函数</span><br><span class="line">    var script = document.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    var showData = <span class="keyword">function</span>(res)&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">'http://192.168.141.210:7310/api/home/cardList?callback=showData'</span>;</span><br><span class="line">    document.head.appendChild(script);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<pre><code>4、后端不存在跨域, 让后端处理
5、借助无跨域的标签，比如img、script
6、设置domain
两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共Cookie。
举例来说，A网站是:http:weibo.qq.com，B网站是:http:lol.qq.com，只需设置document.domain=&apos;qq.com&apos;,两个网页就可共享Cookie。
</code></pre><h2 id="二、性能优化相关"><a href="#二、性能优化相关" class="headerlink" title="二、性能优化相关"></a>二、性能优化相关</h2><h4 id="1、如何优化性能"><a href="#1、如何优化性能" class="headerlink" title="1、如何优化性能"></a>1、如何优化性能</h4><pre><code>网页方面
* 减少http请求次数
    合并文件、css雪碧图
* http缓存
* 减少DOM数量
js方面
    减少操作DOM
    使用外部Javascirpt和CSS文件
图片方面
</code></pre><h2 id="三、es6-ES2017-相关"><a href="#三、es6-ES2017-相关" class="headerlink" title="三、es6(ES2017)相关"></a>三、es6(ES2017)相关</h2><h4 id="1、let、var、const声明变量"><a href="#1、let、var、const声明变量" class="headerlink" title="1、let、var、const声明变量"></a>1、let、var、const声明变量</h4><pre><code>let：声明的变量不能再重新声明, 可以修改值
const：声明的变量不能再重新声明, 如果是基本数据类型, 则不能修改值, 引用类型, 可以改
var：变量可以声明多次, 后面的会替代前面的(存在变量提升), 
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(name) // <span class="string">''</span></span><br><span class="line">console.log(name2) // 报错</span><br><span class="line">getName() // name的值 <span class="string">''</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getName</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'name的值'</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">var name = <span class="string">'张三'</span></span><br><span class="line">getName() // name的值 张三</span><br><span class="line"><span class="built_in">let</span> name2 = <span class="string">'李四'</span></span><br></pre></td></tr></table></figure>
<h4 id="2、什么是类-类的继承"><a href="#2、什么是类-类的继承" class="headerlink" title="2、什么是类, 类的继承"></a>2、什么是类, 类的继承</h4><pre><code>class 、extends
</code></pre><h4 id="3、Promise"><a href="#3、Promise" class="headerlink" title="3、Promise"></a>3、Promise</h4><pre><code>Promise是异步编程的一种解决方案, 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> myPromise = new Promise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">    <span class="keyword">if</span> (/* 异步操作成功 */) &#123;</span><br><span class="line">        resolve ()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">myPromise.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">    // success</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">    // failure</span><br><span class="line">&#125;)</span><br><span class="line">..catch(error =&gt; &#123;···&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="4、async、await"><a href="#4、async、await" class="headerlink" title="4、async、await"></a>4、async、await</h4><pre><code>函数前面多了一个async关键字, 返回一个 Promise 对象, 可以使用then方法添加回调函数。
await关键字只能在async函数内使用, await后面跟着的应该是一个Promise, 如果不是 Promise 对象，就直接返回对应的值。
</code></pre><p><strong>async和promise的区别：</strong><br>    1、async的代码更像同步, 代码比promise更简洁<br>    2、依赖关系多的话, promise会链式调用then, 代码不够简洁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> myPromise (num) &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; 8) &#123;</span><br><span class="line">            resolve <span class="string">'大于'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject <span class="string">'小于'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// Promise</span><br><span class="line"><span class="keyword">function</span> getNum (num) &#123;</span><br><span class="line">    <span class="built_in">return</span> Promise.resolve(num)</span><br><span class="line">&#125;</span><br><span class="line">getNum(9).<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> myPromise(data)</span><br><span class="line">&#125;).<span class="keyword">then</span>(data =&gt; &#123;console.log(data) // 大于&#125;)</span><br><span class="line"></span><br><span class="line">// Async</span><br><span class="line">async <span class="keyword">function</span> getNum (num) &#123;</span><br><span class="line">    <span class="built_in">let</span> result = await myPromise(num)</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">getNum(7).<span class="keyword">then</span>(data =&gt; &#123;console.log(data)&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="5、Set、Map数据结构"><a href="#5、Set、Map数据结构" class="headerlink" title="5、Set、Map数据结构"></a>5、Set、Map数据结构</h4><pre><code>Set: 类似数组, 没有重复的值。使用方法add(), delete(), has(), clear(), size
Map: 类似对象, 键值对的集合, 各种类型的值（包括对象）都可以当作键。使用方法set(), get(), delete(), has(), clear(), size
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Set</span><br><span class="line">const s = new Set();</span><br><span class="line">s.add([1,2,3]);</span><br><span class="line">s.add(&#123;age: 5&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of s) &#123;</span><br><span class="line">    console.log(i); // [1,2,3], &#123;age: 5&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> arr = [...s]; // [[1,2,3], &#123;age: 5&#125;]</span><br><span class="line">// Map</span><br><span class="line">const m = new Map()</span><br><span class="line">const o = &#123;p: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line">const o2 = <span class="string">'职位'</span>;</span><br><span class="line">m.set(o, <span class="string">'打招呼'</span>);</span><br><span class="line">m.set(<span class="string">'o2'</span>, o2); </span><br><span class="line">m.get(<span class="string">'o2'</span>); // 职位</span><br><span class="line">m.get(o); // 打招呼</span><br></pre></td></tr></table></figure>
<h4 id="6、为什么会有es6"><a href="#6、为什么会有es6" class="headerlink" title="6、为什么会有es6"></a>6、为什么会有es6</h4><pre><code>对es5的不足进行补充, 添加新特性
</code></pre><h2 id="四、css、html相关"><a href="#四、css、html相关" class="headerlink" title="四、css、html相关"></a>四、css、html相关</h2><h4 id="1、什么是盒模型-IE盒模型和标准盒模型的区别"><a href="#1、什么是盒模型-IE盒模型和标准盒模型的区别" class="headerlink" title="1、什么是盒模型, IE盒模型和标准盒模型的区别"></a>1、什么是盒模型, IE盒模型和标准盒模型的区别</h4><pre><code>盒模型：元素的外边距（margin）、边框（border）、内边距（padding）、内容（content）组成。
IE模型：width / height = content + padding + border
标准盒模型：width / height = content
box-sizing: content-box(默认标准盒模型) | border-box(IE盒模型) | inherit
</code></pre><h4 id="2、什么是html语义化"><a href="#2、什么是html语义化" class="headerlink" title="2、什么是html语义化"></a>2、什么是html语义化</h4><pre><code>根据内容的结构化, 选择合适的标签, 便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。
</code></pre><h4 id="3、position定位属性有哪些-都是相对什么定位"><a href="#3、position定位属性有哪些-都是相对什么定位" class="headerlink" title="3、position定位属性有哪些, 都是相对什么定位"></a>3、position定位属性有哪些, 都是相对什么定位</h4><pre><code>relative：相对于本身的位置
absolute：相对于一个有position属性的父元素
fixed：相对于浏览器的窗口
static：会按照正常的文档流进行排列
</code></pre><h4 id="4、一个元素水平垂直居中-有哪些方法"><a href="#4、一个元素水平垂直居中-有哪些方法" class="headerlink" title="4、一个元素水平垂直居中 有哪些方法"></a>4、一个元素水平垂直居中 有哪些方法</h4><pre><code>方法一：使用flex
    display: flex;
    align-items: center;
    justify-content: center; 或者 text-align: center;
方法二：使用flex
    父元素——display: flex;
    子元素——margin: auto;
方法三：使用position(未知宽高), 设置父元素为相对定位，给子元素设置绝对定位
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translateX(-50%) translateY(-50%);
</code></pre><h4 id="5、主流浏览器有哪些兼容性问题"><a href="#5、主流浏览器有哪些兼容性问题" class="headerlink" title="5、主流浏览器有哪些兼容性问题"></a>5、主流浏览器有哪些兼容性问题</h4><pre><code>1、某些标签默认的padding和margin不同
解决：设置* {margin: 0, padding: 0}
</code></pre><h4 id="6、标签的套嵌规则"><a href="#6、标签的套嵌规则" class="headerlink" title="6、标签的套嵌规则"></a>6、标签的套嵌规则</h4><pre><code>1、块级元素可以包含行内元素或某些块元素; 但行内元素却不能包含块元素, 它只能包含其它的行内元素
2、块级元素不能放在&lt;p&gt;里面
参考文献[百度](https://blog.csdn.net/yyl927117/article/details/70230044 &quot;标签的嵌套规则&quot;)
</code></pre><h4 id="7、display有哪些属性"><a href="#7、display有哪些属性" class="headerlink" title="7、display有哪些属性"></a>7、display有哪些属性</h4><pre><code>常用：inline、inline-block、flex、table、grid
不常用：table-column、table-cell、table-row、table-row-group、table-column-group、table-header-group、table-footer-group
</code></pre><h4 id="8、浏览器端的渲染机制"><a href="#8、浏览器端的渲染机制" class="headerlink" title="8、浏览器端的渲染机制"></a>8、浏览器端的渲染机制</h4><h4 id="9、css的权值-css引入方式"><a href="#9、css的权值-css引入方式" class="headerlink" title="9、css的权值, css引入方式"></a>9、css的权值, css引入方式</h4><pre><code>权值：!important &gt; style(1000) &gt; id(100) &gt; class(10) &gt; 标签(1)
引用方式：
1、行内样式
    &lt;h1 style=&quot;color:red;&quot;&gt;style属性的应用&lt;/h1&gt;
2、内部样式style标签
    &lt;head&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            h3{
                    color:red;
                }
        &lt;/style&gt;
    &lt;/head&gt;
3、外部引入
    &lt;link type=&quot;text/css&quot; rel=&quot;styleSheet&quot;  href=&quot;CSS文件路径&quot; /&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        @import url(&quot;css文件路径&quot;);
    &lt;/style&gt;
优先级：行内样式 &gt; 内部样式 &gt; 外部引入
</code></pre><h2 id="五、React框架相关"><a href="#五、React框架相关" class="headerlink" title="五、React框架相关"></a>五、React框架相关</h2><h4 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h4><h4 id="2、代码分割"><a href="#2、代码分割" class="headerlink" title="2、代码分割"></a>2、代码分割</h4><pre><code>方法一：react的新特性
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;lazy, Suspense&#125; from <span class="string">'react'</span></span><br><span class="line">const LayoutPage = lazy(() =&gt; import(/* webpackChunkName: <span class="string">'Layout'</span> */ <span class="string">'layout/index.jsx'</span>))</span><br><span class="line">const Layout = <span class="keyword">function</span> (props) &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">            &lt;LayoutPage /&gt;</span><br><span class="line">        &lt;/Suspense&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

方法二：react-loadable
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Loadable from <span class="string">'react-loadable'</span>        </span><br><span class="line">const LayoutPage = Loadable(&#123;</span><br><span class="line">    loader: () =&gt; import(/* webpackChunkName: <span class="string">'Layout'</span> */ <span class="string">'layout/index.jsx'</span>)),</span><br><span class="line">    loading: &lt;div&gt;Loading...&lt;/div&gt;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

方法三：自定义方法实现
</code></pre><h4 id="3、组件深度嵌套时-从顶层组件向最内层组件传递数据-使用新版-Context-API"><a href="#3、组件深度嵌套时-从顶层组件向最内层组件传递数据-使用新版-Context-API" class="headerlink" title="3、组件深度嵌套时, 从顶层组件向最内层组件传递数据, 使用新版 Context API"></a>3、组件深度嵌套时, 从顶层组件向最内层组件传递数据, 使用新版 Context API</h4><pre><code>a: React.createContext 方法用于创建一个 Context 对象。该对象包含 Provider 和 Consumer两个属性，分别为两个 React 组件。
b: Provider 组件。用在组件树中更外层的位置。它接受一个名为 value 的 prop，其值可以是任何 JavaScript 中的数据类型。
c: Consumer 组件。可以在 Provider 组件内部的任何一层使用。它接收一个名为 children 值为一个函数的 prop。这个函数的参数是 Provider 组件接收的那个 value prop 的值，返回值是一个 React 元素（一段 JSX 代码）。
</code></pre><h2 id="六、webpack打包相关"><a href="#六、webpack打包相关" class="headerlink" title="六、webpack打包相关"></a>六、webpack打包相关</h2><h4 id="1、打包原理"><a href="#1、打包原理" class="headerlink" title="1、打包原理"></a>1、打包原理</h4><h4 id="2、background引用图片和img引用图片的区别"><a href="#2、background引用图片和img引用图片的区别" class="headerlink" title="2、background引用图片和img引用图片的区别"></a>2、background引用图片和img引用图片的区别</h4><pre><code>当我们要引用一个图片时，在js文件中要以引用它的html的路径为准；而在css文件中，要以该css的路径为准
</code></pre><p>参考文献<a href="https://www.jianshu.com/p/794c5f301169" title="Webpack打包图片路径问题" target="_blank" rel="noopener">Webpack打包图片路径问题</a></p>
<h4 id="3、contentBase"><a href="#3、contentBase" class="headerlink" title="3、contentBase"></a>3、contentBase</h4><pre><code>安装了html-webpack-plugin后, 此参数可不需要。
作用: 给浏览器访问的页面(虚拟文件)指定根目录, 默认访问html页面, 若没有html页面, 则看到所有文件(类似静态资源服务器)
前提：输出路径是dest, webpack文件在根目录下, 没有html页面
当启动webpack-dev-server的时候, 会在内存中创建dest文件, 在浏览器中访问可以看到跟目录下的所有文件; 
若设置contentBase为a, 在浏览器中访问可以看到a目录下的所有文件；
若有html页面, 则默认访问html页面,看不到所有文件。
</code></pre><h2 id="七、算法"><a href="#七、算法" class="headerlink" title="七、算法"></a>七、算法</h2><h4 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h4><p>原理：对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小(降序)或最大(升序)的元素“浮”到顶端<br>对数子8、70、16、50、6、100、1进行排序<br>第一轮结果：8、16、50、6、70、1、100<br>第二轮结果：8、16、6、50、1、70、100<br>第三轮结果：8、16、6、1、50、70、100<br>第四轮结果：6、8、1、16、50、70、100<br>第五轮结果：6、1、8、16、50、70、100<br>第六轮结果：1、6、8、16、50、70、100<br>总结：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [8, 70, 16, 50, 6, 100, 1]</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i=0; i &lt; arr.length-1; i++) &#123;//外层循环控制排序趟数</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> j=0; j &lt; arr.length-1-i; j++) &#123;//内层循环控制每一趟排序多少次</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">            <span class="built_in">let</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+1];</span><br><span class="line">            arr[j+1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr) // 升序  [1, 6, 8, 16, 50, 70, 100]</span><br></pre></td></tr></table></figure></p>
<h2 id="八、js题"><a href="#八、js题" class="headerlink" title="八、js题"></a>八、js题</h2><h4 id="1、数组去重"><a href="#1、数组去重" class="headerlink" title="1、数组去重"></a>1、数组去重</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,1,2,3,4]</span><br><span class="line">1、[...new Set(arr)];</span><br><span class="line">2、_.uniq(arr);</span><br><span class="line">3、var newArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArr.includes(i)) &#123;</span><br><span class="line">        newArr.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、字符串转number"><a href="#2、字符串转number" class="headerlink" title="2、字符串转number"></a>2、字符串转number</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">'12'</span></span><br><span class="line">1、parseInt(str)、parseFloat(str)</span><br><span class="line">2、Number(str)</span><br><span class="line">3、str - 0</span><br><span class="line">4、_.toNumber(str)</span><br></pre></td></tr></table></figure>
<h4 id="3、-‘1’-‘2’-‘3’-map-parseInt"><a href="#3、-‘1’-‘2’-‘3’-map-parseInt" class="headerlink" title="3、[‘1’, ‘2’, ‘3’].map(parseInt)"></a>3、[‘1’, ‘2’, ‘3’].map(parseInt)</h4><pre><code>结果为：[1, NaN, NaN]
解析:
parseInt最终将字符串转为十进制
parseInt(&apos;1&apos;, 0)   // 结果1。radix为0, 基数为十进制
parseInt(&apos;2&apos;, 1)   // 结果NaN。2&lt;radix&lt;36 
parseInt(&apos;3&apos;, 2)   // 结果NaN。radix为2, 二进制只有0，1
</code></pre><h4 id="4、-‘1’-‘2’-‘3’-filter-parseInt"><a href="#4、-‘1’-‘2’-‘3’-filter-parseInt" class="headerlink" title="4、[‘1’, ‘2’, ‘3’].filter(parseInt)"></a>4、[‘1’, ‘2’, ‘3’].filter(parseInt)</h4><pre><code>结果为：[&apos;1&apos;]
解析:
parseInt最终将字符串转为十进制
parseInt(&apos;1&apos;, 0)   // 结果1。return true
parseInt(&apos;2&apos;, 1)   // 结果NaN。return false
parseInt(&apos;3&apos;, 2)   // 结果NaN。return false
</code></pre><h4 id="5、输出结果-如何解决"><a href="#5、输出结果-如何解决" class="headerlink" title="5、输出结果, 如何解决"></a>5、输出结果, 如何解决</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i=0;i&lt;10;i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i) // 结果: 10个10</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i) // 结果: 0、1、2、3、4、5、6、7、8、9</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> _func = <span class="keyword">function</span> (i) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            console.log(i) // 结果: 0、1、2、3、4、5、6、7、8、9</span><br><span class="line">        &#125;, 0)</span><br><span class="line">    &#125;</span><br><span class="line">    _func(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(</span><br><span class="line">        <span class="keyword">function</span> timer(i) &#123;</span><br><span class="line">            console.log(i) // 结果: 0、1、2、3、4、5、6、7、8、9</span><br><span class="line">    &#125;, 0, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/10/面试问题总结/" data-id="ck1k13z7k0008aouvdmyj04m9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-搭建静态服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/29/搭建静态服务器/" class="article-date">
  <time datetime="2019-09-29T01:34:42.000Z" itemprop="datePublished">2019-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/29/搭建静态服务器/">搭建静态服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、tomcat搭建"><a href="#一、tomcat搭建" class="headerlink" title="一、tomcat搭建"></a>一、tomcat搭建</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>1、安装apcha-tomcat<br>2、安装jdk<br>    下载地址<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>3、配置系统环境变量<br>    添加 JAVA_HOME：C:\Program Files\Java\jdk1.8.0_221 (jdk的安装目录, 根据自身情况修改)<br>    修改 path: %JAVA_HOME%\bin<br>4、测试安装成功<br>    启动服务, 打开bin/startup.bat, 不闪退, 可以访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 即安装成功<br>    命令行输入java -version, 可以看到版本号</p>
<h3 id="部署静态文件-（文件夹名称叫dxs）"><a href="#部署静态文件-（文件夹名称叫dxs）" class="headerlink" title="部署静态文件 （文件夹名称叫dxs）"></a>部署静态文件 （文件夹名称叫dxs）</h3><p>第一种：利用Tomcat自动部署<br>    将dxs文件拷贝到Tomcat的/webapps文件夹下, 然后启动服务器就可以了, Tomcat启动时将自动加载应用。<br>    访问地址如下：<a href="http://localhost:8080/dxs/(默认访问index.html页面，可以修改)" target="_blank" rel="noopener">http://localhost:8080/dxs/(默认访问index.html页面，可以修改)</a></p>
<h5 id="这种方式比较简单，但是web应用程序必须在webapps目录下。Tomcat的Webapps目录是Tomcat默认的应用目录-当服务器启动时-会加载所有这个目录下的应用。"><a href="#这种方式比较简单，但是web应用程序必须在webapps目录下。Tomcat的Webapps目录是Tomcat默认的应用目录-当服务器启动时-会加载所有这个目录下的应用。" class="headerlink" title="这种方式比较简单，但是web应用程序必须在webapps目录下。Tomcat的Webapps目录是Tomcat默认的应用目录, 当服务器启动时, 会加载所有这个目录下的应用。"></a>这种方式比较简单，但是web应用程序必须在webapps目录下。Tomcat的Webapps目录是Tomcat默认的应用目录, 当服务器启动时, 会加载所有这个目录下的应用。</h5><p>第二种：将静态文件部署再任何地方<br>a、修改conf/server.xml文件, 部署指定项目<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">找到下面代码</span><br><span class="line">&lt;Host name=<span class="string">"localhost"</span>  appBase=<span class="string">"webapps"</span> unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;Valve className=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> directory=<span class="string">"logs"</span></span><br><span class="line">        prefix=<span class="string">"localhost_access_log"</span> suffix=<span class="string">".txt"</span></span><br><span class="line">        pattern=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span><br><span class="line">&lt;/Host&gt;</span><br><span class="line">添加节点(根据自身情况修改))</span><br><span class="line">&lt;Context  path =<span class="string">"/dxs"</span>  </span><br><span class="line">    reloadable =<span class="string">"true"</span>  </span><br><span class="line">    docBase =<span class="string">"G:\tomcat-web\dxs"</span>  </span><br><span class="line">    workDir =<span class="string">"G:\tomcat-web\dxs"</span> </span><br><span class="line">/&gt;</span><br><span class="line">&lt;Context  path =<span class="string">"/files"</span>  </span><br><span class="line">    reloadable =<span class="string">"true"</span>  </span><br><span class="line">    docBase =<span class="string">"G:\tomcat-web\files"</span>  </span><br><span class="line">    workDir =<span class="string">"G:\tomcat-web\files"</span> </span><br><span class="line">/&gt;</span><br><span class="line">第一个Context是部署前端页面</span><br><span class="line">第二个Context是部署文件服务器</span><br><span class="line">path：是访问时的根地址，表示访问的路径；如上述例子中，访问该应用程序地址如下：http://localhost:8080/dxs/</span><br><span class="line">reloadable：表示可以在运行时在classes与lib文件夹下自动加载类包。其中reloadable=<span class="string">"false"</span>表示当应用程序中的内容发生更改之后服务器不会自动加载，这个属性在开       发阶段通常都设为<span class="literal">true</span>，方便开发，在发布阶段应该设置为<span class="literal">false</span>，提高应用程序的访问速度。</span><br><span class="line">docbase：表示应用程序的路径，注意斜杠的方向“/”。 docBase可以使用绝对路径，也可以使用相对路径，相对路径相对于webapps。</span><br><span class="line">workdir：表示缓存文件的放置地址，是指Tomcat解析Jsp转换为Java文件，并编译为class存放的文件夹，设置在项目文件夹里面，可以避免移植到其他地方首次读取jsp文件需要重新解析</span><br></pre></td></tr></table></figure></p>
<p>b、若报错：The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">找到以下代码, 将listings对应的<span class="literal">false</span>改为<span class="literal">true</span></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;debug&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;0&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;listings&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;<span class="literal">false</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="修改tomcat默认配置"><a href="#修改tomcat默认配置" class="headerlink" title="修改tomcat默认配置"></a>修改tomcat默认配置</h3><pre><code>1、端口号默认8080
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在conf/server.xml文件找到以下代码, 修改port即可</span><br><span class="line">&lt;Connector port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">    connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">    redirectPort=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure>

2、默认访问index.html页面
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在conf/web.xml文件找到以下代码, 第一个子节点添加&lt;welcome-file&gt;<span class="built_in">test</span>-index.html&lt;/welcome-file&gt;即可</span><br><span class="line">&lt;welcome-file-list&gt;</span><br><span class="line">    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;</span><br><span class="line">    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;</span><br><span class="line">    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;</span><br><span class="line">&lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="开启命令"><a href="#开启命令" class="headerlink" title="开启命令"></a>开启命令</h3><p>点击bin目录下的startup.bat 开启服务</p>
<h2 id="二、window下nginx搭建"><a href="#二、window下nginx搭建" class="headerlink" title="二、window下nginx搭建"></a>二、window下nginx搭建</h2><p>如：nginx安装目录 E:\application\nginx-1.16.1<br>1、安装nginx<br>    安装地址：<a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a><br>2、常用命令<br>打开cmd, 进入E:\application\nginx-1.16.1 执行以下命令<br>停止：nginx -s stop<br>开启：start nginx<br>重启：nginx -s reload<br>3、部署前端页面<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       7006;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   G:/tomcat-web/G-dxs;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    location /api&#123;</span><br><span class="line">        proxy_pass http://192.168.140.196:22224/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考文档：<a href="https://blog.csdn.net/qq_23974323/article/details/80067250" target="_blank" rel="noopener">https://blog.csdn.net/qq_23974323/article/details/80067250</a></p>
<p>4、部署静态文件<br>配置docx、xlsx、txt等文件可以下载, 其他格式的文件可以通过浏览器预览<br><strong>注意</strong>：文件名不能含中文<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       7007;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location /files &#123;</span><br><span class="line">        <span class="built_in">alias</span>   G:/tomcat-web/files;</span><br><span class="line">        autoindex on;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$request_filename</span> ~* ^.*?\.(txt|docx|xlsx)$) &#123; </span><br><span class="line">            add_header Content-Type <span class="string">"application/octet-stream"</span>;</span><br><span class="line">            add_header Content-Disposition: <span class="string">'p_w_upload;'</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、IIS搭建"><a href="#三、IIS搭建" class="headerlink" title="三、IIS搭建"></a>三、IIS搭建</h2><p><strong>前提</strong>：IIS已经搭建成功<br>1、搭建web项目<br>打开IIS, 右击添加网站 -&gt; 填写网站名称, 物理路径(放前端项目的位置), ip地址, 端口 -&gt; 点击确定 -&gt; 点击浏览网站即可<br>2、搭建http文件服务<br>打开IIS, 右击添加网站 -&gt; 填写网站名称, 物理路径(放文件的位置), ip地址, 端口 -&gt; 点击确定 -&gt; 找到目录浏览, 点击开启 -&gt; 点击浏览网站即可</p>
<p>3、安装Application Request Route<br>    请求转发<br>    <a href="https://www.iis.net/downloads/microsoft/application-request-routing" target="_blank" rel="noopener">https://www.iis.net/downloads/microsoft/application-request-routing</a><br>    参考文档：<br>    <a href="https://www.cnblogs.com/yanyangtian/archive/2012/03/26/2417552.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanyangtian/archive/2012/03/26/2417552.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/29/搭建静态服务器/" data-id="ck1k13z7h0005aouvy7c0621u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-console用法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/console用法/" class="article-date">
  <time datetime="2019-07-16T02:04:11.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/console用法/">console用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、输出一个变量或者输出一个字符串"><a href="#一、输出一个变量或者输出一个字符串" class="headerlink" title="一、输出一个变量或者输出一个字符串"></a>一、输出一个变量或者输出一个字符串</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> name1 = <span class="string">'yy'</span></span><br><span class="line"><span class="built_in">let</span> name2 = <span class="string">'zs'</span></span><br><span class="line">console.log(name1, name2); // yy zs</span><br></pre></td></tr></table></figure>
<h2 id="二、支持占位符-不过其支持的占位符种类较少-只支持字符串（-s）-整数（-d或-i）、浮点数（-f）和对象（-o）"><a href="#二、支持占位符-不过其支持的占位符种类较少-只支持字符串（-s）-整数（-d或-i）、浮点数（-f）和对象（-o）" class="headerlink" title="二、支持占位符, 不过其支持的占位符种类较少, 只支持字符串（%s）\整数（%d或%i）、浮点数（%f）和对象（%o）"></a>二、支持占位符, 不过其支持的占位符种类较少, 只支持字符串（%s）\整数（%d或%i）、浮点数（%f）和对象（%o）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">"%d年%d月%d日"</span>, 2019, 09, 22); // 2019年09月22日</span><br></pre></td></tr></table></figure>
<h2 id="三、console-log-、console-warn-、console-error-打印的颜色不一样"><a href="#三、console-log-、console-warn-、console-error-打印的颜色不一样" class="headerlink" title="三、console.log()、console.warn()、console.error() 打印的颜色不一样"></a>三、console.log()、console.warn()、console.error() 打印的颜色不一样</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.warn(<span class="string">'warn'</span>); // 黄色</span><br><span class="line">console.error(<span class="string">'error'</span>); // 红色</span><br><span class="line">console.log(<span class="string">'log'</span>); // 正常黑色</span><br></pre></td></tr></table></figure>
<h2 id="四、console-table-以表格形式输出"><a href="#四、console-table-以表格形式输出" class="headerlink" title="四、console.table() 以表格形式输出"></a>四、console.table() 以表格形式输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const people = &#123;</span><br><span class="line">    <span class="string">"person1"</span>: &#123;<span class="string">"fname"</span>: <span class="string">"san"</span>, <span class="string">"lname"</span>: <span class="string">"zhang"</span>&#125;, </span><br><span class="line">    <span class="string">"person2"</span>: &#123;<span class="string">"fname"</span>: <span class="string">"si"</span>, <span class="string">"lname"</span>: <span class="string">"li"</span>&#125;, </span><br><span class="line">    <span class="string">"person3"</span>: &#123;<span class="string">"fname"</span>: <span class="string">"wu"</span>, <span class="string">"lname"</span>: <span class="string">"wang"</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.table(people)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-47e42c76d29825ad76e0f8db651be5b0_hd.png" alt="效果"></p>
<h2 id="五、console-time-与-console-timeEnd-测试代码运行时间"><a href="#五、console-time-与-console-timeEnd-测试代码运行时间" class="headerlink" title="五、console.time() 与 console.timeEnd() 测试代码运行时间"></a>五、console.time() 与 console.timeEnd() 测试代码运行时间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.time(<span class="string">"for-test"</span>);</span><br><span class="line">const arr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    arr.push(&#123;<span class="string">"key"</span>: i&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.timeEnd(<span class="string">"for-test"</span>);</span><br><span class="line">// <span class="keyword">for</span>-test: 10.705810546875ms</span><br></pre></td></tr></table></figure>
<h2 id="六、console-assert-断言-当表达式为-false-时，输出错误信息Assertion-failed-console-assert"><a href="#六、console-assert-断言-当表达式为-false-时，输出错误信息Assertion-failed-console-assert" class="headerlink" title="六、console.assert() 断言, 当表达式为 false 时，输出错误信息Assertion failed: console.assert"></a>六、console.assert() 断言, 当表达式为 false 时，输出错误信息Assertion failed: console.assert</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, 3, 4]</span><br><span class="line">console.assert(arr.length === 2); // Assertion failed: console.assert</span><br><span class="line">console.assert(arr.length === 4); // undefined</span><br></pre></td></tr></table></figure>
<h2 id="七、console-count-计算代码被执行了多少次"><a href="#七、console-count-计算代码被执行了多少次" class="headerlink" title="七、console.count() 计算代码被执行了多少次"></a>七、console.count() 计算代码被执行了多少次</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">    console.count(<span class="string">"次数"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line">// 输出</span><br><span class="line">次数: 1</span><br><span class="line">次数: 2</span><br><span class="line">次数: 3</span><br></pre></td></tr></table></figure>
<h2 id="八、console-group-、-console-groupEnd-与-console-groupCollapsed-可以展示层级关系"><a href="#八、console-group-、-console-groupEnd-与-console-groupCollapsed-可以展示层级关系" class="headerlink" title="八、console.group()、 console.groupEnd() 与 console.groupCollapsed() 可以展示层级关系"></a>八、console.group()、 console.groupEnd() 与 console.groupCollapsed() 可以展示层级关系</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.group(<span class="string">"1"</span>); // 层级默认展开</span><br><span class="line">console.log(<span class="string">"1-1"</span>);</span><br><span class="line">console.log(<span class="string">"1-2"</span>);</span><br><span class="line">console.log(<span class="string">"1-3"</span>);</span><br><span class="line">console.groupEnd();</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.groupCollapsed(<span class="string">"2"</span>); // 层级默认折叠</span><br><span class="line">console.log(<span class="string">"2-1"</span>);</span><br><span class="line">console.log(<span class="string">"2-2"</span>);</span><br><span class="line">console.log(<span class="string">"2-3"</span>);</span><br><span class="line">console.groupEnd();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-696609e37fad3a14b054285c57172aae_hd.png" alt="效果"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/console用法/" data-id="ck1k13z6t0000aouvqpt7wul7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-css-grid" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/24/css-grid/" class="article-date">
  <time datetime="2019-06-24T03:38:46.000Z" itemprop="datePublished">2019-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/24/css-grid/">css-grid</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、网格布局-Grid"><a href="#一、网格布局-Grid" class="headerlink" title="一、网格布局-Grid"></a>一、网格布局-Grid</h2><p>1、最强大的 CSS 布局方案<br>2、它将网页划分成一个个网格, 可以任意组合不同的网格, 做出各种各样的布局。以前, 只能通过复杂的 CSS 框架达到的效果</p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>1、容器：采用网格布局的区域<br>2、项目：容器内部采用网格布局的子元素, 不包含项目的子元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">'container'</span>&gt;</span><br><span class="line">    &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;p&gt;4&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<pre><code class="bash">上述代码,最外层的&lt;div&gt;就是容器, 内层的三个&lt;div&gt;元素就是项目, &lt;p&gt;元素不属于项目
</code></pre>
<p>3、行: 容器里的水平区域称为行<br>4、列: 容器里的垂直区域称为列<br>5、单元格：行和列的交叉区域<br>正常情况下, n行和m列会产生n x m个单元格<br>6、网格线: 划分网格的线, 水平网格线划分出行, 垂直网格线划分出列<br>正常情况下, n行有n + 1根水平网格线, m列有m + 1根垂直网格线</p>
<h2 id="三、属性之容器属性-定义在容器上的属性"><a href="#三、属性之容器属性-定义在容器上的属性" class="headerlink" title="三、属性之容器属性-定义在容器上的属性"></a>三、属性之容器属性-定义在容器上的属性</h2><h2 id="四、属性之项目属性-定义在项目上的属性"><a href="#四、属性之项目属性-定义在项目上的属性" class="headerlink" title="四、属性之项目属性-定义在项目上的属性"></a>四、属性之项目属性-定义在项目上的属性</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/24/css-grid/" data-id="ck1k13z7f0003aouvtwq1bdwm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-构造函数及原型链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/12/构造函数及原型链/" class="article-date">
  <time datetime="2019-05-12T12:18:11.000Z" itemprop="datePublished">2019-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/12/构造函数及原型链/">构造函数及原型链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、es5-最简单的构造函数和原型链"><a href="#一、es5-最简单的构造函数和原型链" class="headerlink" title="一、es5 最简单的构造函数和原型链"></a>一、es5 最简单的构造函数和原型链</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span> () &#123;</span><br><span class="line">    // 构造函数的属性和方法</span><br><span class="line">    this.name = <span class="string">'张三'</span>;</span><br><span class="line">    this.age = 15;</span><br><span class="line">    // 实例方法</span><br><span class="line">    this.run = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        alert(this.name + <span class="string">'正在运动'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 原型链上添加方法和属性(会被多个实例共享, 构造函数不会)</span><br><span class="line">Person.prototype.sex = <span class="string">'男'</span></span><br><span class="line">Person.prototype.work = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    alert(this.name + <span class="string">'正在工作'</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 静态方法(不需要实例化就可以调用)</span><br><span class="line">Person.getInfo = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    alert(<span class="string">'获取我的信息'</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 调用静态方法</span><br><span class="line">Person.getInfo();// 获取我的信息</span><br><span class="line">// 实例化</span><br><span class="line">var p = new Person()</span><br><span class="line">p.run(); // 张三正在运动</span><br><span class="line">p.work(); // 张三正在工作</span><br></pre></td></tr></table></figure>
<h2 id="二、es5-继承，实现一个web类继承Person"><a href="#二、es5-继承，实现一个web类继承Person" class="headerlink" title="二、es5 继承，实现一个web类继承Person"></a>二、es5 继承，实现一个web类继承Person</h2><p>实现继承的方法：原型链+对象冒充<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person (name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.run = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        alert(this.name + <span class="string">'正在运动'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = <span class="string">'男'</span></span><br><span class="line">Person.prototype.work = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    alert(this.name + <span class="string">'正在工作'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Web (name, age) &#123;</span><br><span class="line">    // 对象冒充可以继承构造函数里面的属性和方法, 没法继承原型链上的属性和方法</span><br><span class="line">    Person.call(this, name, age);</span><br><span class="line">&#125;</span><br><span class="line">// 原型链继承：可以继承原型链上的属性和方法; 也可以继承构造函数里面的属性和方法, 但是实例化子类时没法给父类传参, 即：w1.name = undefined</span><br><span class="line">Web.prototype = new Person(); =&gt; Web.prototype = Person.prototype;</span><br><span class="line"></span><br><span class="line">var w1 = new Web(<span class="string">'张三'</span>, 12)</span><br></pre></td></tr></table></figure></p>
<h2 id="三、es6的class、继承：super、extends"><a href="#三、es6的class、继承：super、extends" class="headerlink" title="三、es6的class、继承：super、extends"></a>三、es6的class、继承：super、extends</h2><p>将上述的构造函数用class实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // 实例化的时候调用</span><br><span class="line">    constructor (name, age) &#123;</span><br><span class="line">        // 类似上述的Person构造函数</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.run = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            alert(this.name + <span class="string">'正在运动'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 类的所有方法|属性都是定义在类的prototype属性上面</span><br><span class="line">    sex: <span class="string">'男'</span>,</span><br><span class="line">    <span class="function"><span class="title">work</span></span>() &#123;</span><br><span class="line">        alert(this.name + <span class="string">'正在工作'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Person(<span class="string">'李四'</span>, 12)</span><br><span class="line"></span><br><span class="line">class Web extends Person &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        super(name, age);// 调用父类的构造函数constructor</span><br><span class="line">    &#125;</span><br><span class="line">    // 扩充自己的方法和属性, 如果子类和父类拥有共同的方法则调用自己的方法</span><br><span class="line">    <span class="function"><span class="title">study</span></span>() &#123;</span><br><span class="line">        alert(this.name, <span class="string">'在学习'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var w1= new Web(<span class="string">'wuwu'</span>, 12)</span><br><span class="line">w1.work();// wuwu正在工作</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/12/构造函数及原型链/" data-id="ck1k13z8g000eaouvshyfomqy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/hello-world/" class="article-date">
  <time datetime="2019-04-01T09:48:30.620Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/hello-world/">hexo基本命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-创建新页面"><a href="#Create-a-new-post-创建新页面" class="headerlink" title="Create a new post 创建新页面"></a>Create a new post 创建新页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server-启动项目"><a href="#Run-server-启动项目" class="headerlink" title="Run server 启动项目"></a>Run server 启动项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites-部署"><a href="#Deploy-to-remote-sites-部署" class="headerlink" title="Deploy to remote sites 部署"></a>Deploy to remote sites 部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/hello-world/" data-id="ck1k13z700001aouvugvflx18" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mac操作linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/27/mac操作linux/" class="article-date">
  <time datetime="2019-02-27T03:14:31.000Z" itemprop="datePublished">2019-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/27/mac操作linux/">mac操作linux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="连接linux服务器"><a href="#连接linux服务器" class="headerlink" title="连接linux服务器"></a>连接linux服务器</h2><pre><code>ssh 账户名@ip地址  （ssh root@199.12.345.678）
ssh -p 端口号 账户名@服务器ip地址（ssh -p 10000 root@199.12.345.678）
</code></pre><h2 id="上传文件到linux服务器——scp方式"><a href="#上传文件到linux服务器——scp方式" class="headerlink" title="上传文件到linux服务器——scp方式"></a>上传文件到linux服务器——scp方式</h2><pre><code>1、mac上传文件到Linux服务器
    scp -p 端口号 文件路径 用户名@服务器ip:目标路径
    如：scp -P10086 /Users/candy/testScp/src.zip root@xxx.xx.xxx.xxx:/root/testScp/server
2、mac上传文件夹到Linux服务器，与上传文件相比多加了-r
    scp -r 文件路径 用户名@服务器ip:目标路径
    如：scp -r /Users/test/testFolder test@www.linuxidc.com:/test/
3、Linux服务器下载文件到mac
    scp 用户名@服务器ip:文件路径 目标路径
    如：scp root@12.122.34.567:/root/node-v8.9.3-linux-x64.tar  /Users/candy
4、Linux服务器下载文件夹到mac，与下载文件相比多加了-r
    scp -r 用户名@服务器ip:文件路径 目标路径
    如：scp -r root@12.122.34.567:/root/node-v8.9.3-linux-x64.tar  /Users/candy
</code></pre><h2 id="上传文件到linux服务器——sftp方式"><a href="#上传文件到linux服务器——sftp方式" class="headerlink" title="上传文件到linux服务器——sftp方式"></a>上传文件到linux服务器——sftp方式</h2><pre><code>选择Shell ----&gt; 选择新建远程连接 ----&gt; 选择安全文件传输 ----&gt; 添加 用户名、ip---&gt; 点击连接 ----&gt; 会弹出窗口，然后执行命令
命令格式：put 本地文件目录 远程主机路径
如：put /Users/candy/testScp/src.zip /root/testScp/server
</code></pre><h2 id="下载-node（7以上版本"><a href="#下载-node（7以上版本" class="headerlink" title="下载 node（7以上版本)"></a>下载 node（7以上版本)</h2><pre><code>方式一：
    1、执行命令  wget https://npm.taobao.org/mirrors/node/v8.11.3/node-v8.11.3-linux-x64.tar.xz
    2、解压 tar xvJf  node-v8.11.3-linux-x64.tar.xz
    3、配置node环境变量
    在根目录 执行 (软连接)  
    ln -s 原路径   目标路径
    例如：
        ln -s /root/node-v8.11.3-linux-x64/bin/node  /usr/local/bin/node
        ln -s /root/node-v8.11.3-linux-x64/bin/npm  /usr/local/bin/npm
方式二：
    执行： curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash
    sudo yum -y install nodejs
    此命令会安装8版本中最高的那个版本
</code></pre><h2 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h2><p>1、linux 窗口 长时间 不动，就会自动中断<br>解决: 使用pm2 <a href="http://www.cnblogs.com/zhongweiv/p/pm2.html#pm2_start" target="_blank" rel="noopener">原文</a><br>PM2 是一个带有负载均衡功能的 Node 应用的进程管理器。<br>安装：npm install pm2 -g  —&gt;软连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pm2相关命令： </span><br><span class="line">a、基本命令</span><br><span class="line">    //app.js页面</span><br><span class="line">    启动进程  pm2 start (node) app.js  //node 可以省略，如果是ts-node</span><br><span class="line">    启动进程  pm2 start ts-node app.js </span><br><span class="line">    停止进程  pm2 stop app.js</span><br><span class="line">    删除进程  pm2 delete app.js</span><br><span class="line">    重载进程  pm2 reload app.js* </span><br><span class="line">    重启进程  pm2 restart app.js</span><br><span class="line">    查看详情  pm2 show <span class="built_in">test</span></span><br><span class="line">    清除日志  pm2 flush</span><br><span class="line">    查看日志  pm2 <span class="built_in">log</span></span><br><span class="line">    命名进程  pm2 start app.js --name device-cloud</span><br><span class="line">    列出由PM2管理的所有进程信息      pm2 list</span><br><span class="line">    打开实时监视器去查看资源占用情况  pm2 monit</span><br><span class="line">b、运行多个项目——批量操作相关命令</span><br><span class="line">    全部重载 pm2 reload all</span><br><span class="line">    全部停止 pm2 stop all</span><br><span class="line">    全部重启 pm2 restart all</span><br><span class="line">    全部删除 pm2 delete all</span><br><span class="line">注意：reload可以做到0秒宕机加载新的代码，restart则是重新启动，生产环境中多用reload来完成代码更新</span><br><span class="line">c、集群——mode模式</span><br><span class="line">    开发环境中mode多以fork的方式启动，生产环境中多用cluster方式启动</span><br><span class="line">    pm2 start app.js -i 数字 --name <span class="built_in">test</span></span><br><span class="line">　　表示在后台以cluster方式运行<span class="built_in">test</span>，数字表示要启动的工作线程的数量</span><br><span class="line">d、监听</span><br><span class="line">    这个项默认是disabled，可以通过如下命令开启</span><br><span class="line">    pm2 start app.js --name <span class="built_in">test</span> --watch</span><br><span class="line">    用处：主要更新代码后，不用重载或重启项目即可以立即让更新的代码起作用</span><br><span class="line">    注意：适合在开发时用，可以省不少时间，生产环境下最好不要用</span><br></pre></td></tr></table></figure></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code>1、ls       列出文件或文件目录
2、cd       切换目录
3、mkdir    创建文件夹
4、unzip ***.zip    解压 .zip文件到当前目录（若提示找不到命令unzip，需要执行yum install -y unzip zip）
5、tar -xvf  ***.tar        解压 .tar文件到当前目录
6、tar xvJf  ***.tar.xz     解压 .tar.xz文件到当前目录
7、rm -r 文件夹名称 -f        强制删除文件夹 
8、rm  文件名   删除文件
9、cat 文件名   查看文件内容
10、vi 文件名   进入文件,按下 i 键 ，出现 -- INSERT-- 就可以编辑了,按esc之后输入:wq, 保存并退出编辑模式 
11、lsof -i:端口号   查看端口号 被哪个进程占用 （yum install lsof）
    kill -9 端口号   杀掉进程
12、pwd             查看当前文件的目录
13、lsb_release -a  获取linux操作系统
14、df -h           磁盘空间
15、echo $LANG      查看linux下当前使用语言命令
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/27/mac操作linux/" data-id="ck1k13z7i0006aouvbrfhjhxs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-flutter移动框架学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/25/flutter移动框架学习/" class="article-date">
  <time datetime="2019-02-25T08:56:19.000Z" itemprop="datePublished">2019-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/25/flutter移动框架学习/">flutter移动框架学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、flutter环境搭建-Mac版"><a href="#一、flutter环境搭建-Mac版" class="headerlink" title="一、flutter环境搭建(Mac版)"></a>一、flutter环境搭建(Mac版)</h2><h3 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h3><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。</p>
<h5 id="1、使用镜像"><a href="#1、使用镜像" class="headerlink" title="1、使用镜像"></a>1、使用镜像</h5><p>由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，可以将如下环境变量加入到系统环境变量中。</p>
<ul>
<li>进入命令窗口</li>
<li>执行 vi .bash_profile</li>
<li>输入 以下 内容<br>export PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="noopener">https://pub.flutter-io.cn</a><br>export FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="noopener">https://storage.flutter-io.cn</a><br>按 esc，输入:wq, 按 enter</li>
<li>执行 source  .bash_profile</li>
</ul>
<h5 id="2、安装Flutter-SDK"><a href="#2、安装Flutter-SDK" class="headerlink" title="2、安装Flutter SDK"></a>2、安装Flutter SDK</h5><p>从github拉取代码，在命令行中执行 以下 操作。</p>
<ul>
<li>git clone -b beta <a href="https://github.com/flutter/flutter.git" target="_blank" rel="noopener">https://github.com/flutter/flutter.git</a></li>
<li>获取代码成功后，进入 fluter 目录，执行 vi .bash_profile，添加<br>export PATH_TO_FLUTTER_GIT_DIRECTORY=/Users/candy/flutter(flutter的目录)<br>export PATH=${PATH}:${PATH_TO_FLUTTER_GIT_DIRECTORY}/bin<br>保存后 执行 source  .bash_profile</li>
<li>执行命令flutter doctor，命令的作用是检测还需要安装的依赖<br>没有出现commond not found：flutter 即是配置成功</li>
</ul>
<p><strong>注意</strong>：<br>a. 以上配置 flutter命令只在当前窗口下的flutter目录下生效，关闭窗口，需要重新执行source  .bash_profile<br>b. flutter doctor 非常慢，需耐心等待</p>
<h5 id="3、配置全局的-flutter-命令"><a href="#3、配置全局的-flutter-命令" class="headerlink" title="3、配置全局的 flutter 命令"></a>3、配置全局的 flutter 命令</h5><ul>
<li>配置系统环境变量，执行 vi .bash_profile</li>
<li>输入 以下 内容<br>export PATH=/Users/candy/flutter/bin:$PATH</li>
<li>保存后 执行 source .bash_profile</li>
</ul>
<p><strong>注意</strong>：<br>a. 以上配置 flutter命令只在当前窗口下生效，关闭窗口，需要重新执行source  .bash_profile</p>
<h5 id="4、Mac-每次都要执行source-bash-profile-配置的环境变量才生效"><a href="#4、Mac-每次都要执行source-bash-profile-配置的环境变量才生效" class="headerlink" title="4、Mac 每次都要执行source ~/.bash_profile 配置的环境变量才生效"></a>4、Mac 每次都要执行source ~/.bash_profile 配置的环境变量才生效</h5><p>解决方案：vi ~/.zshrc, 最后一行加上 source ~/.bash_profile 即可</p>
<h5 id="5、flutter-doctor报错处理参考原文"><a href="#5、flutter-doctor报错处理参考原文" class="headerlink" title="5、flutter doctor报错处理参考原文"></a>5、flutter doctor报错处理<a href="http://www.cnblogs.com/Free-Thinker/p/10212822.html" target="_blank" rel="noopener">参考原文</a></h5><p>a. 下载安装android studio 地址：<a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">https://developer.android.com/studio/index.html</a></p>
<ul>
<li>安装成功后 配置系统环境变量<br>进入命令窗口，执行 vi .bash_profile，添加<br>export ANDROID_HOME=”/Users/candy/Library/Android/sdk” //android sdk目录，替换为自己的<br>export PATH=${PATH}:${ANDROID_HOME}/tools<br>export PATH=${PATH}:${ANDROID_HOME}/platform-tools<br>保存后 执行 source  .bash_profile</li>
<li>执行 flutter doctor –android-licenses </li>
<li>flutter doctor 检测 是否还有错</li>
</ul>
<p>b. 下载安装 Xcode(为了iOS开发)<br>下载地址：<a href="https://developer.apple.com/xcode/download/" target="_blank" rel="noopener">https://developer.apple.com/xcode/download/</a><br><strong>注意</strong>:<br>要为iOS开发Flutter应用程序，需要Xcode 至少9.0.0版本。<br>Xcode对Mac版本有要求，Xcode 9以上版本 需要Mac版本至少 10.13.2。</p>
<p>安装完之后，按报错的 提示 一步步执行命令即可</p>
<h2 id="二、编辑器的配置"><a href="#二、编辑器的配置" class="headerlink" title="二、编辑器的配置"></a>二、编辑器的配置</h2><p><strong>推荐使用 VS Code</strong><br>1、需要安装两个插件:<br>    Flutter插件： 支持Flutter开发工作流 (运行、调试、热重载等)。<br>    Dart插件： 提供代码分析 (输入代码时进行验证、代码补全等)。<br>2、点击命令面板 ——&gt; 输入flutter ——&gt; 选择 Flutter：New Project ——&gt; 输入项目名称，不能有大写<br>3、安装模拟器并调试<br>    点击右下角的 No Device，可以 安装模拟器<br>    窗口里 执行命令 flutter run 调试，按 r 键 刷新<br>    获取设备列表：执行 flutter emulator</p>
<h2 id="三、添加配置项"><a href="#三、添加配置项" class="headerlink" title="三、添加配置项"></a>三、添加配置项</h2><p>1、在pubspec.yaml文件中的dependencies下添加 english_words: ^3.1.0<br>目的：避免引入无用的包</p>
<h2 id="四、基础知识了解"><a href="#四、基础知识了解" class="headerlink" title="四、基础知识了解"></a>四、基础知识了解</h2><h5 id="A-lib-main-dart"><a href="#A-lib-main-dart" class="headerlink" title="A. lib/main.dart"></a>A. lib/main.dart</h5><p>此文件是每一个flutter项目的默认入口文件，也就是说每个flutter项目启动的时候，默认先运行这个文件的代码。</p>
<h5 id="B-pubspec-yaml"><a href="#B-pubspec-yaml" class="headerlink" title="B  pubspec.yaml"></a>B  pubspec.yaml</h5><p>此文件为项目配置文件</p>
<h5 id="C-import-‘package-flutter-material-dart’"><a href="#C-import-‘package-flutter-material-dart’" class="headerlink" title="C. import ‘package:flutter/material.dart’;"></a>C. import ‘package:flutter/material.dart’;</h5><p>每一个.dart文件的第一行都会导入flutter/material.dart包，这个包是Flutter实现Material Design设计风格的基础包，里面有文本输入框(Text)、图标(Icon)、图片(Image)、行排列布局(Align)、列排列布局(Column)、Decoration)、异步、动画等等等等控件，大家可以理解为网页中的按钮、标题、选项框呀等等控件库吧。<br><strong>注意</strong>：Material Design是啥？是谷歌推出的一套视觉设计语言。比如有的APP可以换皮肤，而每一套皮肤就是一种设计语言，有古典风呀炫酷风呀极简风呀等等。</p>
<h5 id="D-void-main-gt-runApp-new-MyApp"><a href="#D-void-main-gt-runApp-new-MyApp" class="headerlink" title="D. void main() =&gt; runApp(new MyApp())"></a>D. void main() =&gt; runApp(new MyApp())</h5><p>这里的main()函数是Dart程序的入口，也就是说，Flutter程序在运行的时候，第一个执行的函数就是main()函数。</p>
<h5 id="E-StatelessWidget和StatefulWidget"><a href="#E-StatelessWidget和StatefulWidget" class="headerlink" title="E. StatelessWidget和StatefulWidget"></a>E. StatelessWidget和StatefulWidget</h5><p>这是flutter最基础的的两种控件类，分别叫无状态类和有状态类。<br>两者的差别在于是否有状态，玩家创建的所有控件都继承自这两个控件。当你想展示的内容只需要改动控件本身的配置信息就可以实现时，例如文本、图片等，可以考虑使用无状态控件（StatelessWidget）。如果你想展示的内容是可以动态改变才能实现时，例如滚动列表、动画效果等，可以考虑使用有状态控件（StatefulWidget）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/25/flutter移动框架学习/" data-id="ck1k13z720002aouvveyj8kg2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-模块化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/20/模块化/" class="article-date">
  <time datetime="2019-02-20T07:14:42.000Z" itemprop="datePublished">2019-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/20/模块化/">模块化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h2><ul>
<li>解决命名冲突</li>
<li>提供复用性</li>
<li>提高代码可维护性</li>
</ul>
<h2 id="模块化的实现"><a href="#模块化的实现" class="headerlink" title="模块化的实现"></a>模块化的实现</h2><p>1、早期，使用立即执行函数，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(globalVariable)&#123;</span><br><span class="line">   globalVariable.test = <span class="function"><span class="title">function</span></span>() &#123;&#125;</span><br><span class="line">   // ... 声明各种变量、函数都不会污染全局作用域</span><br><span class="line">&#125;)(globalVariable)</span><br></pre></td></tr></table></figure></p>
<p>2、AMD、CMD，已很少见到<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// AMD</span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123;</span><br><span class="line">    // 加载模块完毕可以使用</span><br><span class="line">    a.do()</span><br><span class="line">    b.do()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// CMD</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    // 加载模块</span><br><span class="line">    // 可以把 require 写在函数体的任意地方实现延迟加载</span><br><span class="line">    var a = require(<span class="string">'./a'</span>)</span><br><span class="line">    a.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>3、CommonJS，最早在Node中使用，目前仍然广泛使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">//暴露模块</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line">// or</span><br><span class="line">exports.a = 1;</span><br><span class="line">exports.b = 2;</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">//引入模块</span><br><span class="line">var module = require(<span class="string">'./a.js'</span>);</span><br><span class="line">console.log(module);//&#123;a: 1, b: 2&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//module的基本实现</span><br><span class="line">module = &#123;</span><br><span class="line">    id: <span class="string">'XXX'</span>,// 我总得知道怎么去找到他吧</span><br><span class="line">    exports: &#123;&#125;,// exports 就是个空对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>exports 和 module.exports 的区别<br>1、exports 和 module.exports 指向相同的内存地址<br>2、require() 返回的是 module.exports 而不是 exports<br>3、不能直接对 exports 赋值，因为会导致exports 和 module.exports不再指向同一个内存地址，修改并不会对 module.exports 起效</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'example1:'</span></span><br><span class="line">// a.js</span><br><span class="line">exports.a = 1;</span><br><span class="line">exports.b = 3;//exports 和 module.exports 指向相同的内存地址,所以module.exports = &#123;a: 1, b: 3&#125;</span><br><span class="line">exports = &#123;c: 5&#125;;//exports指向了另一个引用地址，module.exports还是&#123;a: 1, b: 3&#125;</span><br><span class="line">// b.js</span><br><span class="line">//引入模块</span><br><span class="line">var module = require(<span class="string">'./a.js'</span>);//返回的是module.exports = &#123;a: 1, b: 3&#125;</span><br><span class="line">console.log(module);//&#123;a: 1, b: 3&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'example2:'</span></span><br><span class="line">// a.js</span><br><span class="line">exports = &#123;c: 5&#125;;//exports指向了另一个引用地址，与module.exports互不影响，module.exports是&#123;&#125;</span><br><span class="line">exports.a = 1;</span><br><span class="line">exports.b = 3;</span><br><span class="line">// b.js</span><br><span class="line">//引入模块</span><br><span class="line">var module = require(<span class="string">'./a.js'</span>);//返回的是module.exports = &#123;&#125;</span><br><span class="line">console.log(module);//&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'example3:'</span></span><br><span class="line">// a.js</span><br><span class="line">exports.a = 1;</span><br><span class="line">exports.b = 3;</span><br><span class="line">console.log(exports);//&#123;a: 1, b: 3&#125;</span><br><span class="line">console.log(module.exports);////&#123;a: 1, b: 3&#125;</span><br><span class="line">console.log(exports === module.exports);//<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="string">'example4:'</span></span><br><span class="line">// a.js</span><br><span class="line">module.exports = &#123;a: 1&#125;;</span><br><span class="line">console.log(exports);//&#123;&#125;</span><br><span class="line">console.log(module.exports);//&#123;a: 1&#125;</span><br><span class="line">console.log(exports === module.exports);//<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>4、es6提出import、export2个命令<br>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
<p>export命令可以输出 变量、函数或类</p>
<ul>
<li>export 与 export default的区别<br> 1、export default命令, import加载模块的时候可以自定义模块名称, 并且不想要使用大括号(与export命令的区别)<br> 2、在一个模块中 只能有一个 export default, 可以有多个export</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//XX.js</span><br><span class="line">var name = <span class="string">'小红'</span>;</span><br><span class="line">var addFunc = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">//导出多个模块</span><br><span class="line"><span class="built_in">export</span> &#123;name, addFunc&#125;;</span><br><span class="line">import &#123;name, addFunc&#125; from <span class="string">'XX.js'</span>;</span><br><span class="line">console.log(name, addFunc);//输出 小红 ƒ <span class="function"><span class="title">addFunc</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">//模块整体加载</span><br><span class="line">import * as allVar from <span class="string">'XX.js'</span>;</span><br><span class="line">console.log(allVar.name);// <span class="string">'小红'</span></span><br><span class="line">console.log(allVar.addFunc);// ƒ <span class="function"><span class="title">addFunc</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">//<span class="built_in">export</span> 使用 as 对模块 重命名</span><br><span class="line"><span class="built_in">export</span> &#123;addFunc as add&#125;;</span><br><span class="line">import &#123;add&#125; from <span class="string">'XX.js'</span>;</span><br><span class="line">console.log(add);//输出 ƒ <span class="function"><span class="title">addFunc</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">//import 使用 as 对模块 重命名</span><br><span class="line">import &#123;add as addFunction&#125; from <span class="string">'XX.js'</span>;</span><br><span class="line">console.log(addFunction);//输出 ƒ <span class="function"><span class="title">addFunc</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">//<span class="built_in">export</span>命令中 使用 as default 指定模块的默认输出</span><br><span class="line"><span class="built_in">export</span> &#123;name as default, addFunc&#125;;</span><br><span class="line">import name, &#123;addFunc&#125; from <span class="string">'XX.js'</span>;</span><br><span class="line">console.log(name);//输出 <span class="string">'小红'</span></span><br><span class="line">console.log(addFunc);//输出 ƒ <span class="function"><span class="title">addFunc</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//导入 默认模块</span><br><span class="line"><span class="built_in">export</span> default <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line">import customFunc from <span class="string">'XX.js'</span>;</span><br><span class="line">customFunc();//<span class="string">'foo'</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/20/模块化/" data-id="ck1k13z7t000baouvyx26azx2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-常用git命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/31/常用git命令/" class="article-date">
  <time datetime="2019-01-31T05:44:14.000Z" itemprop="datePublished">2019-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/31/常用git命令/">常用git命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h2><pre><code>合并某次提交： git cherry-pick commitid
合并某个分支： git merge 分支
</code></pre><h2 id="操作分支"><a href="#操作分支" class="headerlink" title="操作分支"></a>操作分支</h2><pre><code>删除远程分支：git push origin --delete  name
删除本地分支：git branch -D name
查看当前分支：git branch
查看所有分支：git branch -a
切换分支：git checkout name
创建分支：git branch name
</code></pre><h2 id="操作tag"><a href="#操作tag" class="headerlink" title="操作tag"></a>操作tag</h2><pre><code>创建：git tag -a name -m “描述”
推送：git push origin name
删除本地：git tag -d name
删除远程：git push origin --delete tag  name
</code></pre><h2 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h2><pre><code>将当前分支修改的内容放到缓存区中, 并会自动建立一个缓存的list集合：git stash
查看list集合下的所有缓存: git stash list
将编号x的缓存释放出来, 释放之后该缓存还存在于list中: git stash apply @{x} 
将当前分支的最后一次暂存的内容释放出来, 该缓存还存在于list中：git stash apply
将当前分支的最后一次暂存的内容释放出来, 该缓存会从list中删除：git stash pop
</code></pre><h2 id="改变项目引用地址"><a href="#改变项目引用地址" class="headerlink" title="改变项目引用地址"></a>改变项目引用地址</h2><pre><code>改变：git remote set-url origin 地址
查看：git remote -v
单个删除：git remote remove 地址
全部删除：git remote remove origin
</code></pre><h2 id="共钥、私钥"><a href="#共钥、私钥" class="headerlink" title="共钥、私钥"></a>共钥、私钥</h2><pre><code>检查SSH keys是否存在：ls -al ~/.ssh
生成共钥：ssh-keygen -t rsa -C &quot;邮箱&quot; / ssh-keygen
查看公钥：cat ~/.ssh/id_rsa.pub
查看私钥：cat ~/.ssh/id_rsa
</code></pre><p><strong>注意1</strong>：生成公钥时，按照默认提示要输入两次密码，但是如果输入了，每次操作操作git库时都要输入密码，所以选择不输入密码<br><strong>注意2</strong>：生成公钥时，报错 bash:ssh-keygen command not found，解决办法：配置系统环境变量Path, 添加ssh-keygen.exe的路径(默认在Git/usr/bin)</p>
<h2 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h2><pre><code>查看占用端口：lsof -i tcp:8080
杀死进程：kill -9 750
</code></pre><h2 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h2><pre><code>查看修改的文件：git diff
提交到暂存区：git add
提交：git commit -m&apos;描述&apos;
</code></pre><h2 id="本地代码回滚"><a href="#本地代码回滚" class="headerlink" title="本地代码回滚"></a>本地代码回滚</h2><pre><code>查看commit id：git log
代码回滚：git reset --hard  commitId
</code></pre><h2 id="执行一次git-pull-后-获取有更改的文件列表"><a href="#执行一次git-pull-后-获取有更改的文件列表" class="headerlink" title="执行一次git pull 后 获取有更改的文件列表"></a>执行一次git pull 后 获取有更改的文件列表</h2><pre><code>git diff HEAD
</code></pre><h2 id="上传本地项目到github"><a href="#上传本地项目到github" class="headerlink" title="上传本地项目到github"></a>上传本地项目到github</h2><pre><code>1. 进入到上传的文件的目录下，使用命令初始化本地仓库
    git init
2. 把本地仓库和远程仓库相关联，其中origin是远程仓库的别名，可以自己改变。
    git remote add origin [url]
3. 如果远程仓库不为空，要把本地仓库和远程仓库做同步。否则可以省略此步骤，其中master为远程仓库的分支名。
    git pull --rebase origin master
4. 提交代码
    git commit -m&apos;描述&apos;
5. 把本地仓库中的文件同步到远程仓库中。其中master为远程仓库的分支名。
    git push -u origin master
</code></pre><h2 id="git-配置项（git-默认对文件名大小写不敏感-不区分文件名大小写-）"><a href="#git-配置项（git-默认对文件名大小写不敏感-不区分文件名大小写-）" class="headerlink" title="git 配置项（git 默认对文件名大小写不敏感 (不区分文件名大小写)）"></a>git 配置项（git 默认对文件名大小写不敏感 (不区分文件名大小写)）</h2><p><a href="https://www.worldhello.net/gotgit/08-git-misc/030-case-insensitive.html" target="_blank" rel="noopener">原文链接</a></p>
<pre><code>git config --list    获取git的所有配置项
git config core.ignorecase false     配置git 使其对文件名大小写敏感
</code></pre><h2 id="同步vscode配置项到其他电脑"><a href="#同步vscode配置项到其他电脑" class="headerlink" title="同步vscode配置项到其他电脑"></a>同步vscode配置项到其他电脑</h2><pre><code>一、上传配置到github
    1. vscode 安装 Settings Sync 插件
    2. 登陆GitHub 进入Settings\Developer settings\Personal access tokens 界面，点击 Generate new token, 输入 Token description, 勾选 gist, 点击 Generate token。
    3. 复制生成的token，回到vscode，在任意界面按 Alt + Shift + U，在对话框中输入该token, 回车, 等待配置上传成功。
    4. 在用户设置中可以查看, 打开 setting.json, 可以看到 sync.gist 字段。
二、在另一台电脑下载配置
    1. 安装Settings Sync插件
    2. 按快捷键Alt + Shift + d, 会弹出一个输入框, 根据提示，先输入GitHub Token, 再输入GitHub Gist, 回车后将会自动下载之前上传的配置
</code></pre><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><pre><code>把名字添加到dependencies：npm install XX --save
把名字添加到devDependencies：npm install XX -D
</code></pre><h2 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h2><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre><h2 id="node版本管理及切换—-Nodejs-版本管理器-mac"><a href="#node版本管理及切换—-Nodejs-版本管理器-mac" class="headerlink" title="node版本管理及切换—-Nodejs 版本管理器(mac)"></a>node版本管理及切换—-Nodejs 版本管理器(mac)</h2><pre><code>npm install -g n
n latest    下载最近版本的node
n lts       下载最近最稳定的node
n ls        列出所有的node版本
n  版本号    切换node 版本
</code></pre><h2 id="nrm-管理源—npm的镜像源管理工具"><a href="#nrm-管理源—npm的镜像源管理工具" class="headerlink" title="nrm 管理源—npm的镜像源管理工具"></a>nrm 管理源—npm的镜像源管理工具</h2><pre><code>npm install -g nrm
nrm ls                  列出所有可切换的源
nrm use taobao          切换镜像
nrm add 仓库名 地址     添加仓库
</code></pre><h2 id="初始化package-json文件"><a href="#初始化package-json文件" class="headerlink" title="初始化package.json文件"></a>初始化package.json文件</h2><pre><code>npm init
</code></pre><h2 id="npm-set用来设置环境变量"><a href="#npm-set用来设置环境变量" class="headerlink" title="npm set用来设置环境变量"></a>npm set用来设置环境变量</h2><pre><code>npm set init-author-name &apos;Your name&apos;
npm set init-author-email &apos;Your email&apos;
npm set init-author-url &apos;http://yourdomain.com&apos;
npm set init-license &apos;MIT&apos;
面命令等于为 npm init 设置了默认值，以后执行 npm init 的时候，package.json 的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。
</code></pre><h2 id="npm-清楚缓存"><a href="#npm-清楚缓存" class="headerlink" title="npm 清楚缓存"></a>npm 清楚缓存</h2><pre><code>npm cache verify
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/31/常用git命令/" data-id="ck1k13z7l0009aouv1t53l3ci" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/10/面试问题总结/">面试问题总结</a>
          </li>
        
          <li>
            <a href="/2019/09/29/搭建静态服务器/">搭建静态服务器</a>
          </li>
        
          <li>
            <a href="/2019/07/16/console用法/">console用法</a>
          </li>
        
          <li>
            <a href="/2019/06/24/css-grid/">css-grid</a>
          </li>
        
          <li>
            <a href="/2019/05/12/构造函数及原型链/">构造函数及原型链</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Candy<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>