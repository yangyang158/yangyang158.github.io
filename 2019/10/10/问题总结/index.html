<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>问题总结 | 学无止境</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、原生js基础相关变量区分大小写1、数据类型有哪些基本数据类型(存放在栈中)：string、number、boolean、null、undefined、symbol 引用类型(存放在堆中)：object、function 注意1: 栈和堆的区别    栈（stack）为自动分配的内存空间, 它由系统自动释放; 而堆（heap）则是动态分配的内存, 大小不定也不会自动释放注意2: null和und">
<meta property="og:type" content="article">
<meta property="og:title" content="问题总结">
<meta property="og:url" content="https://yangyang158.github/2019/10/10/问题总结/index.html">
<meta property="og:site_name" content="学无止境">
<meta property="og:description" content="一、原生js基础相关变量区分大小写1、数据类型有哪些基本数据类型(存放在栈中)：string、number、boolean、null、undefined、symbol 引用类型(存放在堆中)：object、function 注意1: 栈和堆的区别    栈（stack）为自动分配的内存空间, 它由系统自动释放; 而堆（heap）则是动态分配的内存, 大小不定也不会自动释放注意2: null和und">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://yangyang158.github/2019/10/10/问题总结/event-loop.png">
<meta property="og:image" content="https://yangyang158.github/2019/10/10/问题总结/mvc.png">
<meta property="og:image" content="https://yangyang158.github/2019/10/10/问题总结/mvvm.png">
<meta property="og:updated_time" content="2020-09-10T01:13:42.792Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="问题总结">
<meta name="twitter:description" content="一、原生js基础相关变量区分大小写1、数据类型有哪些基本数据类型(存放在栈中)：string、number、boolean、null、undefined、symbol 引用类型(存放在堆中)：object、function 注意1: 栈和堆的区别    栈（stack）为自动分配的内存空间, 它由系统自动释放; 而堆（heap）则是动态分配的内存, 大小不定也不会自动释放注意2: null和und">
<meta name="twitter:image" content="https://yangyang158.github/2019/10/10/问题总结/event-loop.png">
  
    <link rel="alternate" href="/atom.xml" title="学无止境" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">学无止境</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yangyang158.github"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-问题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/10/问题总结/" class="article-date">
  <time datetime="2019-10-10T01:32:48.000Z" itemprop="datePublished">2019-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      问题总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、原生js基础相关"><a href="#一、原生js基础相关" class="headerlink" title="一、原生js基础相关"></a>一、原生js基础相关</h2><h4 id="变量区分大小写"><a href="#变量区分大小写" class="headerlink" title="变量区分大小写"></a>变量区分大小写</h4><h4 id="1、数据类型有哪些"><a href="#1、数据类型有哪些" class="headerlink" title="1、数据类型有哪些"></a>1、数据类型有哪些</h4><pre><code>基本数据类型(存放在栈中)：string、number、boolean、null、undefined、symbol
引用类型(存放在堆中)：object、function
</code></pre><p><strong>注意1:</strong> 栈和堆的区别<br>    栈（stack）为自动分配的内存空间, 它由系统自动释放; 而堆（heap）则是动态分配的内存, 大小不定也不会自动释放<br><strong>注意2:</strong> null和undefined的区别<br>    typeof undefined   // undefined<br>    typeof null        // object<br>    null === undefined // false<br>    null == undefined  // true</p>
<h4 id="2、如何判断数据的类型"><a href="#2、如何判断数据的类型" class="headerlink" title="2、如何判断数据的类型"></a>2、如何判断数据的类型</h4><pre><code>typeof 可以正确的判断基本数据类型的类型, 但是对于对象, 都是object, 对于函数都是function
Object.prototype.toString.call(param) 可以判断基本数据类型和引用数据类型的类型
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeof [] === <span class="string">'object'</span></span><br><span class="line">typeof &#123;&#125; === <span class="string">'object'</span></span><br><span class="line">typeof alert === <span class="string">'function'</span></span><br><span class="line">typeof null === <span class="string">'object'</span> (一个存在很久的bug)</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // <span class="string">"[object Object]"</span></span><br><span class="line">Object.prototype.toString.call([])  // <span class="string">"[object Array]"</span></span><br></pre></td></tr></table></figure>
</code></pre><h4 id="3、判断是不是某构造函数的实例"><a href="#3、判断是不是某构造函数的实例" class="headerlink" title="3、判断是不是某构造函数的实例"></a>3、判断是不是某构造函数的实例</h4><pre><code>instanceof：通过原型链判断
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person (name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> p1 = new Person(<span class="string">'张三'</span>)</span><br><span class="line">p1 instanceof Person // <span class="literal">true</span> p1是构造函数Person的实例</span><br><span class="line">Person[Symbol.hasInstance](p1) // <span class="literal">true</span> 与上面等价</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="4、等号赋值、浅拷贝、深拷贝的区别"><a href="#4、等号赋值、浅拷贝、深拷贝的区别" class="headerlink" title="4、等号赋值、浅拷贝、深拷贝的区别"></a>4、等号赋值、浅拷贝、深拷贝的区别</h4><p><a href="https://www.haorooms.com/post/js_copy_sq" target="_blank" rel="noopener">https://www.haorooms.com/post/js_copy_sq</a><br>等号赋值：新数据和原数据指向同一引用<br>浅拷贝：新数据和原数据不指向同一个引用, 如果原数据里包含子对象, 新旧子对象共享同一块内存<br>深拷贝：会另外创造一个一模一样的对象, 新对象跟原对象不共享内存, 修改新对象不会改到原对象<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####浅拷贝的实现方式:</span></span><br><span class="line"></span><br><span class="line">第一种：lodash的方法_.cclone</span><br><span class="line">第二种：...  注意：必须含有子对象</span><br><span class="line">第三种：Object.assgin(), 注意：obj里必须含有子对象</span><br><span class="line">var obj = &#123; a: &#123;msg: <span class="string">"hello"</span>, num: 21&#125;, b:3 &#125;;</span><br><span class="line">var cloneObj = Object.assign(&#123;&#125;, obj);</span><br><span class="line">obj === cloneObj; // <span class="literal">false</span></span><br><span class="line">obj.a.num = 66;</span><br><span class="line">obj.b = 10;</span><br><span class="line">console.log(cloneObj.a.num); // 66</span><br><span class="line">console.log(cloneObj.b); // 3</span><br><span class="line">第四种：自定义方法</span><br><span class="line"><span class="keyword">function</span> shallowClone(initalObj) &#123;    </span><br><span class="line">    var obj = &#123;&#125;;    </span><br><span class="line">    <span class="keyword">for</span> ( var i <span class="keyword">in</span> initalObj) &#123;</span><br><span class="line">        obj[i] = initalObj[i];</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: <span class="string">"hello"</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        a: <span class="string">"world"</span>,</span><br><span class="line">        b: 21</span><br><span class="line">    &#125;,</span><br><span class="line">    c: [<span class="string">"Bob"</span>, <span class="string">"Tom"</span>, <span class="string">"Jenny"</span>],</span><br><span class="line">    d: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        alert(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var cloneObj = shallowClone(obj); </span><br><span class="line">cloneObj === obj; // <span class="literal">false</span></span><br><span class="line">// 新数据和原数据的b、c、d指向同一引用</span><br><span class="line">cloneObj.b.a = <span class="string">"changed"</span>; // obj和cloneObj都改变</span><br><span class="line">cloneObj.c[0] = 6; // obj和cloneObj都改变</span><br><span class="line">cloneObj.d = <span class="function"><span class="title">function</span></span>() &#123; alert(<span class="string">"changed"</span>); &#125; // obj的d属性不改变</span><br><span class="line"></span><br><span class="line"><span class="comment">#####深拷贝的实现方式:</span></span><br><span class="line">第一种：用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象</span><br><span class="line">第二种：对象只有一层的话可以使用上面的：Object.assign()函数</span><br><span class="line">第三种：...  注意：不能含有子对象</span><br><span class="line">第四种：lodash的_.cloneDeep</span><br><span class="line">第五种：自定义方法，递归拷贝</span><br><span class="line">//  使用递归的方式实现数组、对象的深拷贝</span><br><span class="line"><span class="keyword">function</span> deepClone(obj) &#123;</span><br><span class="line">    //判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝</span><br><span class="line">    var objClone = Array.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line">    //进行深拷贝的不能为空，并且是对象或者是</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; typeof obj === <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obj[key] &amp;&amp; typeof obj[key] === <span class="string">"object"</span>) &#123;</span><br><span class="line">                    objClone[key] = deepClone1(obj[key])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    objClone[key] = obj[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line">deepClone(&#123;name: <span class="string">'yy'</span>, age: 12, obj: &#123;color: <span class="string">'res'</span>, big: <span class="literal">true</span>&#125;, arr: [1, 2, 3]&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="5、什么是闭包-闭包的作用-为什么要使用闭包"><a href="#5、什么是闭包-闭包的作用-为什么要使用闭包" class="headerlink" title="5、什么是闭包, 闭包的作用, 为什么要使用闭包"></a>5、什么是闭包, 闭包的作用, 为什么要使用闭包</h4><pre><code>匿名函数本身也是一个闭包
闭包：函数A里面有一个函数B, 函数B可以访问到函数A里面的局部变量, 函数B就是闭包
本质：闭包是将函数内部和函数外部连接起来的桥梁
作用：1、可以读取函数内部的变量 2、让一些变量始终保持在内存中
为什么要使用闭包：在函数外部无法读取函数内部的局部变量, 如果想要获取, 可以在函数里在声明一个函数
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 想要在函数外部获取f1里面的变量n, 所以需要在f1里声明一个f2, 并作为返回值</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">    var n = 999;</span><br><span class="line">    nAdd = <span class="function"><span class="title">function</span></span>() &#123;n += 1&#125;; // 没用var声明, 则是全局变量</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>()&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> f2; // f2就是闭包</span><br><span class="line">&#125;</span><br><span class="line">var result = f1();</span><br><span class="line">result(); // 999</span><br><span class="line">nAdd();</span><br><span class="line">result(); // 1000</span><br></pre></td></tr></table></figure>
<p>1、首先函数f1执行后将f2赋给了全局变量result，所以f2始终在内存中，函数f2在函数f1内部，所以在f2的内部可以访问到f1的变量n。<br>2、因为f2的存在依赖了f1中的变量n，所以使得f1也始终被存储在了内存中，在调用之后，不会被垃圾回收机制回收。（内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被释放,因为闭包需要它们）</p>
<h4 id="6、构造函数和继承"><a href="#6、构造函数和继承" class="headerlink" title="6、构造函数和继承"></a>6、构造函数和继承</h4><pre><code>构造函数作用：需要大批量的创建对象的时候，就需要用到构造函数，它可以方便创建多个对象的实例
A为父类, 在子类B的构造函数里调用父类的构造函数，拷贝一份父类的原型 作为 子类的原型
实例化new 的过程中会发生以上四件事情：
    a、新生成了一个对象
    b、链接到原型, 将他的_proto_指向其构造函数的prototype
    c、绑定 this，this指向新对象
    d、返回新对象
</code></pre><h4 id="7、什么是原型？什么是原型链"><a href="#7、什么是原型？什么是原型链" class="headerlink" title="7、什么是原型？什么是原型链"></a>7、什么是原型？什么是原型链</h4><pre><code>构造函数的prototype属性指向原型,原型的constructor属性指回构造函数,实例的_proto_指向原型。
所有实例共享原型上的属性和方法
</code></pre><h4 id="8、浏览器端缓存"><a href="#8、浏览器端缓存" class="headerlink" title="8、浏览器端缓存"></a>8、浏览器端缓存</h4><pre><code>cookie：与服务器端通信,每次都会携带在HTTP头中，保存在客户端浏览器上，不是很安全。cookie的长度和数量受限制,每个domain最多只能有20条cookie,每个cookie长度不能超过4KB。否则会被截掉。
sessionStorage: 仅在当前会话下有效,关闭页面或浏览器后被清除,存放数据大小为一般为5MB,在客户端中保存,不参与和服务器的通信
localStorage：存放数据大小为一般为5MB,在客户端中保存,不参与和服务器的通信
session: 保存在服务器上，比cookie安全，但是当访问增多，会比较占用服务器的性能
</code></pre><h4 id="9、同步和异步、并发和并行、线程和多线程和单线程、进程"><a href="#9、同步和异步、并发和并行、线程和多线程和单线程、进程" class="headerlink" title="9、同步和异步、并发和并行、线程和多线程和单线程、进程"></a>9、同步和异步、并发和并行、线程和多线程和单线程、进程</h4><pre><code>并行: 同一时刻发生两个或者多个事件。比如：并行：你吃饭吃到一半, 电话来了, 你一边打电话一边吃饭
并发: 同一时科两个或多个事件在间隔发生。比如：你吃饭吃到一半, 电话来了, 你停了下来接了电话, 接完后继续吃饭

进程: 当一个程序开始运行时, 它就是一个进程, 一个进程又是由多个线程所组成的
多线程: 一个程序中可以同时运行多个不同的线程
单线程: 一个程序中只有一个线程

进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元
同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程
进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束
多线程的目的是提高cpu利用率

同步：A请求回来了再发B请求
异步：A请求和B请求可以同时发
</code></pre><h4 id="10、for循环有哪些方法及区别"><a href="#10、for循环有哪些方法及区别" class="headerlink" title="10、for循环有哪些方法及区别"></a>10、for循环有哪些方法及区别</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [2,4,1,5,7]</span><br><span class="line">arr.length= 5</span><br><span class="line"><span class="built_in">let</span> obj = &#123;name: <span class="string">'张三'</span>, age: 12&#125;</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'abcdefg123'</span></span><br><span class="line">// 支持数组、字符串</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i=0;i&lt;=str.length-1;i++) &#123;</span><br><span class="line">    console.log(i, arr[i]) // i是索引</span><br><span class="line">&#125;</span><br><span class="line">//  支持数组、字符串、对象</span><br><span class="line">// 缺点(针对数组)：可以将属性打印出来</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    console.log(i, arr[i]) // i是索引0,1,2,3,4,length</span><br><span class="line">&#125;</span><br><span class="line">//  支持数组、字符串(es6提出,解决<span class="keyword">for</span>-in的缺陷, 只返回具有数字索引的属性)</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of arr) &#123;</span><br><span class="line">    console.log(value) // value 是值, 不是索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、箭头函数和普通函数的this指向"><a href="#11、箭头函数和普通函数的this指向" class="headerlink" title="11、箭头函数和普通函数的this指向"></a>11、箭头函数和普通函数的this指向</h4><pre><code>箭头函数：如果包裹在函数中, 只取决包裹箭头函数的第一个普通函数的this
普通函数：this由函数调用时决定
</code></pre><h4 id="12、break、continue、return的区别"><a href="#12、break、continue、return的区别" class="headerlink" title="12、break、continue、return的区别"></a>12、break、continue、return的区别</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myBreak</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(var j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">        console.log(<span class="string">'j'</span>, j)</span><br><span class="line">        <span class="keyword">for</span>(var i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == 2) &#123;</span><br><span class="line">                <span class="built_in">break</span>; // j:0,i:0,i:1;j:1,i:0,i:1;j:2,i:0,i:1</span><br><span class="line">                <span class="built_in">continue</span>; // j:0,i:0,i:1,i:3;j:1,i:0,i:1,i:3;j:2,i:0,i:1,i:3</span><br><span class="line">                <span class="built_in">return</span>; // j:0,i:0,i:1</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(<span class="string">'i'</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myBreak();</span><br></pre></td></tr></table></figure>
<pre><code>break: 跳出当前循环(如果嵌套多层循环, 只能跳出当前一层循环)
continue: 用于跳过当次循环, 还会继续循环
return: 结束函数的调用
</code></pre><h4 id="13、forEach、map、filter的区别"><a href="#13、forEach、map、filter的区别" class="headerlink" title="13、forEach、map、filter的区别"></a>13、forEach、map、filter的区别</h4><pre><code>forEach: 只是简单的将数组遍历, 不会改变原数组, 没有返回值
map: 方法里有return的话, 会返回新数组, 不会改变原数组; 也可以直接处理每一项的值, 会改变原数组 
filter: 使用return, 返回满足条件的新数组, 不会改变原数组
</code></pre><h4 id="14、字符串、数组、数字有哪些方法"><a href="#14、字符串、数组、数字有哪些方法" class="headerlink" title="14、字符串、数组、数字有哪些方法"></a>14、字符串、数组、数字有哪些方法</h4><pre><code>String对象方法：concat、indexOf、lastIndexOf、split、slice、substring、substr、toLowerCase、toUpperCase、trim、replace、toString、valueOf
Array对象方法：concat、join、indexOf、lastIndexOf、slice、splice、push、pop、shift、unshift、reverse、includes、reduce、find、findIndex、map、filter、forEach、some、isArray、sort、toString、valueOf
Number对象方法：toFixed、toString、valueOf
Boolean 对象方法：toString、valueOf
注意数组的sort方法:
sort()并不是按照数值进行排序，而是按字符串字母的ASCII码值进行比较排序的，所以当数组项为数字时，sort()也会自动先将数字转换成字符串，然后再按字母比较的规则进行排序处理。
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [8, 70, 16, 50, 6, 100, 1];</span><br><span class="line"><span class="keyword">function</span> compare (a, b) &#123;</span><br><span class="line">    console.log(a, b)</span><br><span class="line">    <span class="built_in">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> result = arr.sort(compare)</span><br><span class="line">console.log(<span class="string">'result'</span>, result) // 升序： [1, 6, 8, 16, 50, 70, 100]</span><br></pre></td></tr></table></figure>
<h4 id="15、什么是对象-面向对象和面向过程的区别"><a href="#15、什么是对象-面向对象和面向过程的区别" class="headerlink" title="15、什么是对象, 面向对象和面向过程的区别"></a>15、什么是对象, 面向对象和面向过程的区别</h4><pre><code>对象：拥有属性和方法的集合。在js里一切皆对象, 小轿车就是一个对象, 拥有轮胎、窗等属性, 方法有启动停止等
面向对象：封装, 继承, 多态的特点。碰到相同的问题可以直接调用
面向过程：分析出解决问题所需要的步骤, 然后用函数把这些步骤一步一步实现
举例：洗碗
面向过程：先把碗放到水池里 -&gt; 放水 -&gt; 倒洗洁精 -&gt; 用抹布洗 -&gt; 冲洗 -&gt; 拿出来晾干
面向对象：封装一个洗碗机
</code></pre><h4 id="16、长连接"><a href="#16、长连接" class="headerlink" title="16、长连接"></a>16、长连接</h4><pre><code>websocket：服务端主动向客户端推送消息
let w1 = new WebSocket(SOCKETURL)
onopen(): 连接成功
onmesage(): 接受消息
close(): 关闭连接
</code></pre><p><strong>注：</strong> 使用Nginx代理WebSocket,如果在60秒(默认)内没有数据交互,就会自动断开连接<br>    websocket和http的区别:<br>    1、http的通信只能由客户端发起，websocket可以主动向客户端发送消息</p>
<h4 id="17、js的三种类型转换"><a href="#17、js的三种类型转换" class="headerlink" title="17、js的三种类型转换"></a>17、js的三种类型转换</h4><pre><code>转换为布尔值、转换为数字、转换为字符串
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">原始值值类型</th>
<th style="text-align:left">转换目标</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left">除了’’, 其余都是true</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left">除了0、-0、NaN, 其余都是true</td>
</tr>
<tr>
<td style="text-align:left">null、undefined</td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">number、symbol</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">5 =&gt; ‘5’、String(Symbol()) =&gt; “Symbol()”</td>
</tr>
<tr>
<td style="text-align:left">function</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">String(function getName () {}) =&gt; “function getName () {}”</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">true =&gt; ‘true’、false =&gt; ‘false’</td>
</tr>
<tr>
<td style="text-align:left">数组</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">[] =&gt; ‘’、[1, 2] =&gt; ‘1,2’</td>
</tr>
<tr>
<td style="text-align:left">对象</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">“[object Object]”</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">‘’ =&gt; 0、’1’ =&gt; 1、’2sdsd’ =&gt; NaN</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">false =&gt; 0、true =&gt; 1</td>
</tr>
<tr>
<td style="text-align:left">数组</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">[] =&gt; 0、[1] =&gt; 1、[1,2] =&gt; NaN</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">undefined、除了数组的引用类型</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">NaN</td>
</tr>
<tr>
<td style="text-align:left">symbol</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">报错</td>
</tr>
</tbody>
</table>
<pre><code>==比较时都进行的哪些隐形转换
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">左边操作符类型</th>
<th style="text-align:left">右边操作符类型</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">number</td>
<td style="text-align:left">将string转为number</td>
</tr>
<tr>
<td style="text-align:left">string、number、bool</td>
<td style="text-align:left">string、number、bool</td>
<td style="text-align:left">将不是number的转为number</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">undefined</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">NaN</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
<p>如果存在引用数据类型，会先调用valueOf或者toString，在进行判断</p>
<h4 id="18、浅比较和深比较的区别"><a href="#18、浅比较和深比较的区别" class="headerlink" title="18、浅比较和深比较的区别"></a>18、浅比较和深比较的区别</h4><p>浅比较：判断2个对象的引用地址是否一样<br>深比较：判断2个对象的所有属性值是否一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 浅比较</span><br><span class="line">const obj1 = &#123;age: 12&#125;</span><br><span class="line">const obj2 = &#123;age: 12&#125;</span><br><span class="line">const obj3 = obj1</span><br><span class="line">obj1 === obj2; // <span class="literal">false</span></span><br><span class="line">obj3 === obj1; // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="19、栈、堆、队列"><a href="#19、栈、堆、队列" class="headerlink" title="19、栈、堆、队列"></a>19、栈、堆、队列</h4><p>栈: 先进后出的有序集合，js的基本数据类型都存放在栈中，栈由编译器自动分配释放，调用完毕自动释放。<br>堆：一般由操作人员（程序员）分配释放，若操作人员不分配释放，将由OS回收释放，js的引用数据类型都存放在堆中<br>队列：先进先出的有序集合<br><strong>为什么会有堆内存、栈内存之分？</strong><br>通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。<br>当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；<br>当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。<br>1、什么是垃圾<br>    不在被使用的就是垃圾，会被回收<br>2、如何进行垃圾回收<br>    v8引擎使用可达性算法，从根节点出来，能遍历到的对象就是可达的，不能被遍历到的，就是不可达，会被回收<br>    根节点有哪些：window、放在栈中的值<br>3、何时回收垃圾<br>    浏览器将数据分为两种，一种是「临时」对象，一种是「长久」对象。<br>临时对象：<br>    大部分对象在内存中存活的时间很短。比如函数内部声明的变量，或者块级作用域中的变量。当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。这类对象很快就变得不可访问，应该快点回收。<br>长久对象：<br>    生命周期很长的对象，比如全局的 window、DOM、Web API 等等。这类对象可以慢点回收。<br>    这两种对象对应不同的回收策略，所以，V8 把堆分为新生代和老生代两个区域，<br>    新生代中存放临时对象，老生代中存放持久对象。<br>4、浏览器中不同类型变量的内存都是何时释放？<br>    引用类型： 不再被引用就会回收<br>    值类型：<br>5、哪些情况会导致内存泄露？如何避免？<br>    内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来<br>    如：绑定的事件没有被销毁、声明的全局变量但不被使用</p>
<h4 id="20、JavaScript-运行机制"><a href="#20、JavaScript-运行机制" class="headerlink" title="20、JavaScript 运行机制"></a>20、JavaScript 运行机制</h4><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" title="阮一峰" target="_blank" rel="noopener">参考文献</a></p>
<p><strong>宏任务、微任务</strong><br>宏任务：可以理解是每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)。主要场景有：主代码块script、setTimeout、setInterval等<br>微任务：可以理解是在当前task执行结束后立即执行的任务。主要场景有：Promise、process.nextTick等。<br><strong>运行机制</strong><br>js是单线程，分为同步任务和异步任务<br>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。(事件循环)<br>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>
<p><img src="/2019/10/10/问题总结/event-loop.png" alt="运行机制" title="运行机制"></p>
<h4 id="21、防抖和节流：减少不必要的损耗"><a href="#21、防抖和节流：减少不必要的损耗" class="headerlink" title="21、防抖和节流：减少不必要的损耗"></a>21、防抖和节流：减少不必要的损耗</h4><p>防抖：动作触发后间隔一段时间 触发某个事件，如果在这段时间内又触发了该动作，则从此刻起 计算间隔时间<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> debounce(fn, time) &#123;</span><br><span class="line">    <span class="built_in">let</span> timerId: any = null</span><br><span class="line">    <span class="built_in">return</span> () =&gt; &#123;</span><br><span class="line">        clearTimeout(timerId)</span><br><span class="line">        timerId = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn(<span class="string">'yy'</span>, 12)</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sayHello</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'test'</span>, arguments)</span><br><span class="line">&#125;</span><br><span class="line">// 效果: 点击一个按钮, 4秒后触发sayHello函数</span><br><span class="line"><span class="built_in">let</span> btn: any = document.querySelector(<span class="string">'.tets'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, debounce(sayHello, 4000))</span><br></pre></td></tr></table></figure></p>
<p>节流：动作触发后间隔一段时间 触发某个事件，如果在这段时间内又触发了该动作，则无视该动作<br>例如：8s内无论重复触发多少次该动作，都只触发一次该事件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> throtte(fn, time) &#123;</span><br><span class="line">    <span class="built_in">let</span> preTime = 0</span><br><span class="line">    <span class="built_in">return</span> () =&gt; &#123;</span><br><span class="line">        // 时间戳</span><br><span class="line">        <span class="built_in">let</span> now = Date.now()</span><br><span class="line">        <span class="keyword">if</span> (now - preTime &gt; time) &#123;</span><br><span class="line">            fn()</span><br><span class="line">            preTime = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>  <span class="function"><span class="title">sayHello</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'节流'</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 效果: 重复点击一个按钮, 8秒后只会触发一次sayHello函数</span><br><span class="line"><span class="built_in">let</span> btn: any = document.querySelector(<span class="string">'.tets'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, this.throtte(this.sayHello, 8000))</span><br></pre></td></tr></table></figure></p>
<h5 id="22、JavaScript设计模式"><a href="#22、JavaScript设计模式" class="headerlink" title="22、JavaScript设计模式"></a>22、JavaScript设计模式</h5><pre><code>单例模式：保证一个类只有一个实例
工厂模式：构造函数
观察者模式：addEventListener
装饰者模式：给对象动态添加属性和方法
代理模式：比如：事件代理
</code></pre><h5 id="23、JavaScript架构模式"><a href="#23、JavaScript架构模式" class="headerlink" title="23、JavaScript架构模式"></a>23、JavaScript架构模式</h5><pre><code>(1) MVC: 数据层 + 视图层 + 控制器 (单向传递)
(2) MVP: 数据层 + 视图层 + 展示器
(3) MVVM: Model + View + ViewModel (双向传递), 是基于MVC和MVP的架构模式, Angular、Vue
    model和view没有关系，他们通过ViewModel进行交互(viewModel通过双向绑定将view和model连接起来), Model 和 ViewModel 之间的交互是双向的, 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
</code></pre><p><img src="/2019/10/10/问题总结/mvc.png" alt="MVC模式" title="MVC模式"><br><img src="/2019/10/10/问题总结/mvvm.png" alt="MVVM模式" title="MVVM模式"></p>
<h5 id="24、script异步加载的方法"><a href="#24、script异步加载的方法" class="headerlink" title="24、script异步加载的方法"></a>24、script异步加载的方法</h5><pre><code>1、script标签的defer属性：页面渲染 和 脚本的加载 并行执行， 脚本的执行需要等所有元素解析完成后
2、script标签的async属性: 页面渲染 和 脚本的加载、执行 并行执行 ---html5提出
3、script标签设置type=&quot;module&quot;, 类似defer
4、动态创建script脚本
</code></pre><h5 id="25、精度丢失问题解决"><a href="#25、精度丢失问题解决" class="headerlink" title="25、精度丢失问题解决"></a>25、精度丢失问题解决</h5><pre><code>a、如：0.1 + 0.2 !== 0.3
解决方案：将小数转为整数，然后再转回来。如：(1 + 2) / 10
b、如：0.4737*100 = 47.370000000000005
解决方式：parseFloat(val*100).toFixed(2)
</code></pre><h5 id="26、原生组件的优缺点"><a href="#26、原生组件的优缺点" class="headerlink" title="26、原生组件的优缺点"></a>26、原生组件的优缺点</h5><p>table<br>    缺点：<br>    1、扩展性不好, 结构太复杂, 布局变更 可能需要重新开发<br>    2、加载慢<br>    3、table嵌table, 不好维护<br>    优点：<br>    1、开发快<br>    2、没有浏览器兼容性问题<br>    3、不用顾及文本垂直水平居中的问题<br>iframe<br>    优点：<br>    1、可以引入第三方页面<br>    2、form表单提交不跳转页面<br>    缺点：<br>    1、无法被搜索引擎搜到<br>    2、阻塞页面加载, window的onload事件需要在所有iframe加载完毕后(包含里面的元素)才会触发, 所以会动态的设置iframe的src避免该问题</p>
<h2 id="二、ajax请求相关"><a href="#二、ajax请求相关" class="headerlink" title="二、ajax请求相关"></a>二、ajax请求相关</h2><h4 id="1、post和get的区别"><a href="#1、post和get的区别" class="headerlink" title="1、post和get的区别"></a>1、post和get的区别</h4><pre><code>post：url在body体中, url长度限制是特定的浏览器及服务器对它的限制
get：参数拼接在url上, 出于安全考虑, 服务器端在实现时会做一定限制, nginix默认限制1M, Tomcat 默认是2M
</code></pre><p><strong>注意1:</strong> HTTP 协议规范没有对 get和post的URL 长度进行限制<br><strong>注意2:</strong> 不同浏览器对url长度的限制<br>IE: 2803<br>Firefox: 65536<br>Chrome: 8182<br>Safari: 80000<br>Opera: 190000</p>
<h4 id="2、什么是跨域-跨域有哪些解决方法"><a href="#2、什么是跨域-跨域有哪些解决方法" class="headerlink" title="2、什么是跨域, 跨域有哪些解决方法"></a>2、什么是跨域, 跨域有哪些解决方法</h4><pre><code>跨域：协议、ip、端口号 有一个不一样就是跨域
解决方案：
1、postMessage进行信息传递, HTML5的新api, 可以在不同的iframe之间传递消息
2、CORS：只需服务端设置Access-Control-Allow-Origin即可, 若要带cookie请求, 前后端都需要设置
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加<span class="string">'/'</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://www.domain1.com"</span>); </span><br><span class="line">// 允许前端带认证cookie：启用此项后，上面的域名不能为<span class="string">'*'</span>，必须指定具体的域名，否则浏览器会提示</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>); </span><br><span class="line">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type,X-Requested-With"</span>);</span><br></pre></td></tr></table></figure>
<pre><code>3、JSONP, 借助script标签
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 请求地址后面加一个callback=函数名, 后台返回 函数名(<span class="string">'我请求到了'</span>), 就能调用到该函数</span><br><span class="line">    var script = document.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    window.showData = <span class="keyword">function</span>(res)&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">'http://192.168.141.210:7310/api/home/cardList?callback=showData'</span>;</span><br><span class="line">    document.head.appendChild(script);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">koa 模拟后端处理</span><br><span class="line">@get(<span class="string">'/home/cardList'</span>)</span><br><span class="line">async GetCardeList(ctx)&#123;</span><br><span class="line">    // 获取请参参数</span><br><span class="line">    <span class="built_in">let</span> func = ctx.query.callback</span><br><span class="line">    // 复杂的响应</span><br><span class="line">    ctx.body = func + `(<span class="variable">$&#123;JSON.stringify(['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'])&#125;</span>)`</span><br><span class="line">    // 简单的响应</span><br><span class="line">    ctx.body = func + `(<span class="string">'哈哈哈哈'</span>)`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>4、后端不存在跨域, 让后端处理
5、借助无跨域的标签，比如img、script
6、设置domain
两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共Cookie。
举例来说，A网站是:http:weibo.qq.com，B网站是:http:lol.qq.com，只需设置document.domain=&apos;qq.com&apos;,两个网页就可共享Cookie。
</code></pre><h5 id="4、两个tab之间进行通信"><a href="#4、两个tab之间进行通信" class="headerlink" title="4、两个tab之间进行通信"></a>4、两个tab之间进行通信</h5><pre><code>1、两个打开的tab页面属于同源范畴
    localStorage、sessionStorage、Cookie
2、完全没有关系的两个浏览器的tab通信
    A、B Tab 引入iframe 并且指向同一个页面, 利用postMessage通信
</code></pre><h2 id="二、性能优化相关"><a href="#二、性能优化相关" class="headerlink" title="二、性能优化相关"></a>二、性能优化相关</h2><h4 id="1、如何优化性能"><a href="#1、如何优化性能" class="headerlink" title="1、如何优化性能"></a>1、如何优化性能</h4><pre><code>a、DNS预解析（不能滥用）
    eg：
    // 开启预解析
    &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;
    // 关闭预解析
    &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt;
    // link的设置会让浏览器预取&quot;www.zhix.net&quot;的解析
    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.zhix.net&quot;&gt;
b、http缓存
c、CDN加速-适合处理静态文件
    原理：把内容发布到世界的各个节点，用户可以在距离最近的网络节点获取到内容, 减少网络传输距离达到加速的目的
b、代码层面
    1) 防抖、节流
    2) 减少http请求次数
        合并文件、css雪碧图
    3) js、css、图片等资源进行压缩
    4) 减少操作频繁DOM
    5) 图片预加载、懒加载
</code></pre><h2 id="三、es6-ES2017-相关"><a href="#三、es6-ES2017-相关" class="headerlink" title="三、es6(ES2017)相关"></a>三、es6(ES2017)相关</h2><h4 id="1、let、var、const声明变量"><a href="#1、let、var、const声明变量" class="headerlink" title="1、let、var、const声明变量"></a>1、let、var、const声明变量</h4><pre><code>let：声明的变量不能再重新声明, 可以修改值
const：声明的变量不能再重新声明, 如果是基本数据类型, 则不能修改值, 引用类型, 可以改
let、const 在全局声明的变量 不会挂载到window上
var：变量可以声明多次, 后面的会替代前面的(存在变量提升),
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(name) // <span class="string">''</span></span><br><span class="line">console.log(name2) // 报错</span><br><span class="line">getName() // name的值 <span class="string">''</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getName</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'name的值'</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">var name = <span class="string">'张三'</span></span><br><span class="line">getName() // name的值 张三</span><br><span class="line"><span class="built_in">let</span> name2 = <span class="string">'李四'</span></span><br></pre></td></tr></table></figure>
<h4 id="2、什么是类-类的继承"><a href="#2、什么是类-类的继承" class="headerlink" title="2、什么是类, 类的继承"></a>2、什么是类, 类的继承</h4><pre><code>class 、extends
</code></pre><h4 id="3、Promise"><a href="#3、Promise" class="headerlink" title="3、Promise"></a>3、Promise</h4><pre><code>Promise是异步编程的一种解决方案, 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> myPromise = new Promise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">    <span class="keyword">if</span> (/* 异步操作成功 */) &#123;</span><br><span class="line">        resolve ()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">myPromise.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">    // success</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">    // failure</span><br><span class="line">&#125;)</span><br><span class="line">..catch(error =&gt; &#123;···&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="4、async、await"><a href="#4、async、await" class="headerlink" title="4、async、await"></a>4、async、await</h4><pre><code>函数前面多了一个async关键字, 返回一个 Promise 对象, 可以使用then方法添加回调函数。
await关键字只能在async函数内使用, await后面跟着的应该是一个Promise, 如果不是 Promise 对象，就直接返回对应的值。
</code></pre><p><strong>async和promise的区别：</strong><br>    1、async的代码更像同步, 代码比promise更简洁<br>    2、依赖关系多的话, promise会链式调用then, 代码不够简洁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> myPromise (num) &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; 8) &#123;</span><br><span class="line">            resolve <span class="string">'大于'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject <span class="string">'小于'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// Promise</span><br><span class="line"><span class="keyword">function</span> getNum (num) &#123;</span><br><span class="line">    <span class="built_in">return</span> Promise.resolve(num)</span><br><span class="line">&#125;</span><br><span class="line">getNum(9).<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> myPromise(data)</span><br><span class="line">&#125;).<span class="keyword">then</span>(data =&gt; &#123;console.log(data) // 大于&#125;)</span><br><span class="line"></span><br><span class="line">// Async</span><br><span class="line">async <span class="keyword">function</span> getNum (num) &#123;</span><br><span class="line">    <span class="built_in">let</span> result = await myPromise(num)</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">getNum(7).<span class="keyword">then</span>(data =&gt; &#123;console.log(data)&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="5、Set、Map数据结构"><a href="#5、Set、Map数据结构" class="headerlink" title="5、Set、Map数据结构"></a>5、Set、Map数据结构</h4><pre><code>Set: 类似数组, 没有重复的值。使用方法add(), delete(), has(), clear(), size
Map: 类似对象, 键值对的集合, 各种类型的值（包括对象）都可以当作键。使用方法set(), get(), delete(), has(), clear(), size
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Set</span><br><span class="line">const s = new Set();</span><br><span class="line">s.add([1,2,3]);</span><br><span class="line">s.add(&#123;age: 5&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of s) &#123;</span><br><span class="line">    console.log(i); // [1,2,3], &#123;age: 5&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> arr = [...s]; // [[1,2,3], &#123;age: 5&#125;]</span><br><span class="line">// Map</span><br><span class="line">const m = new Map()</span><br><span class="line">const o = &#123;p: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line">const o2 = <span class="string">'职位'</span>;</span><br><span class="line">m.set(o, <span class="string">'打招呼'</span>);</span><br><span class="line">m.set(<span class="string">'o2'</span>, o2); </span><br><span class="line">m.get(<span class="string">'o2'</span>); // 职位</span><br><span class="line">m.get(o); // 打招呼</span><br></pre></td></tr></table></figure>
<h4 id="6、为什么会有es6"><a href="#6、为什么会有es6" class="headerlink" title="6、为什么会有es6"></a>6、为什么会有es6</h4><pre><code>对es5的不足进行补充, 添加新特性
</code></pre><h4 id="7、promise的原理是什么-手写一个promise"><a href="#7、promise的原理是什么-手写一个promise" class="headerlink" title="7、promise的原理是什么, 手写一个promise"></a>7、promise的原理是什么, 手写一个promise</h4><pre><code>Promise有pedding、fulfilled、rejected 3种状态, 可以从pedding转fulfilled, 也可以从pedding转rejected, 且状态不可逆,  fulfilled、rejected之间不能相互转换
</code></pre><h2 id="四、css、html相关"><a href="#四、css、html相关" class="headerlink" title="四、css、html相关"></a>四、css、html相关</h2><h4 id="1、什么是盒模型-IE盒模型和标准盒模型的区别"><a href="#1、什么是盒模型-IE盒模型和标准盒模型的区别" class="headerlink" title="1、什么是盒模型, IE盒模型和标准盒模型的区别"></a>1、什么是盒模型, IE盒模型和标准盒模型的区别</h4><pre><code>盒模型：元素的外边距（margin）、边框（border）、内边距（padding）、内容（content）组成。
IE模型：width / height = content + padding + border
标准盒模型：width / height = content
box-sizing: content-box(默认标准盒模型) | border-box(IE盒模型) | inherit
</code></pre><h4 id="2、什么是html语义化"><a href="#2、什么是html语义化" class="headerlink" title="2、什么是html语义化"></a>2、什么是html语义化</h4><pre><code>根据内容的结构化, 选择合适的标签, 便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。
</code></pre><h4 id="3、position定位属性有哪些-都是相对什么定位"><a href="#3、position定位属性有哪些-都是相对什么定位" class="headerlink" title="3、position定位属性有哪些, 都是相对什么定位"></a>3、position定位属性有哪些, 都是相对什么定位</h4><pre><code>relative：相对于本身的位置
absolute：相对于一个有position属性的父元素
fixed：相对于浏览器的窗口
static：会按照正常的文档流进行排列
</code></pre><h4 id="4、一个元素水平垂直居中-有哪些方法"><a href="#4、一个元素水平垂直居中-有哪些方法" class="headerlink" title="4、一个元素水平垂直居中 有哪些方法"></a>4、一个元素水平垂直居中 有哪些方法</h4><pre><code>方法一：使用flex
    display: flex;
    align-items: center;
    justify-content: center; 或者 text-align: center;
方法二：使用flex
    父元素——display: flex;
    子元素——margin: auto;
方法三：使用position(未知宽高), 设置父元素为相对定位，给子元素设置绝对定位
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translateX(-50%) translateY(-50%);
</code></pre><h4 id="5、主流浏览器有哪些兼容性问题"><a href="#5、主流浏览器有哪些兼容性问题" class="headerlink" title="5、主流浏览器有哪些兼容性问题"></a>5、主流浏览器有哪些兼容性问题</h4><pre><code>1、某些标签默认的padding和margin不同
解决：设置* {margin: 0, padding: 0}
</code></pre><h4 id="6、标签的套嵌规则"><a href="#6、标签的套嵌规则" class="headerlink" title="6、标签的套嵌规则"></a>6、标签的套嵌规则</h4><pre><code>1、块级元素可以包含行内元素或某些块元素; 但行内元素却不能包含块元素, 它只能包含其它的行内元素
2、块级元素不能放在&lt;p&gt;里面
参考文献[百度](https://blog.csdn.net/yyl927117/article/details/70230044 &quot;标签的嵌套规则&quot;)
</code></pre><h4 id="7、display有哪些属性"><a href="#7、display有哪些属性" class="headerlink" title="7、display有哪些属性"></a>7、display有哪些属性</h4><pre><code>常用：inline、inline-block、flex、table、grid
不常用：table-column、table-cell、table-row、table-row-group、table-column-group、table-header-group、table-footer-group
</code></pre><h4 id="8、浏览器端的渲染机制"><a href="#8、浏览器端的渲染机制" class="headerlink" title="8、浏览器端的渲染机制"></a>8、浏览器端的渲染机制</h4><h4 id="9、css的权值-css引入方式"><a href="#9、css的权值-css引入方式" class="headerlink" title="9、css的权值, css引入方式"></a>9、css的权值, css引入方式</h4><pre><code>权值：!important &gt; style(1000) &gt; id(100) &gt; class(10) &gt; 标签(1)
引用方式：
1、行内样式
    &lt;h1 style=&quot;color:red;&quot;&gt;style属性的应用&lt;/h1&gt;
2、内部样式style标签
    &lt;head&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            h3{
                    color:red;
                }
        &lt;/style&gt;
    &lt;/head&gt;
3、外部引入
    &lt;link type=&quot;text/css&quot; rel=&quot;styleSheet&quot;  href=&quot;CSS文件路径&quot; /&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        @import url(&quot;css文件路径&quot;);
    &lt;/style&gt;
优先级：行内样式 &gt; 内部样式 &gt; 外部引入
</code></pre><h4 id="10、html有哪些空标签"><a href="#10、html有哪些空标签" class="headerlink" title="10、html有哪些空标签"></a>10、html有哪些空标签</h4><pre><code>没有闭合的标签称为空标签
如: &lt;img /&gt;  &lt;hr /&gt;  &lt;br /&gt;  &lt;input /&gt; &lt;meta /&gt; &lt;link /&gt;等
</code></pre><h4 id="11、h5有哪些"><a href="#11、h5有哪些" class="headerlink" title="11、h5有哪些"></a>11、h5有哪些</h4><p><strong>注： HTML5是HTML的第五个版本</strong><br>    <strong>html5 ≈ html + css3 + js + api</strong><br>    新增了一些标签、表单控件、样式选择器、伪类、表单校验<br>    localstorage、sessionStorage、离线存储<br>    map、地理位置<br>    canvas、svg<br>    音频、视频<br>    Web SQL 数据库<br>    动画<br>    WebSocket<br>    拖拽<br>    Web Workers：运行在后台的 JavaScript，为javascript创造多线程的环境，分配一些任务在后台运行。限制：同源限制、无法获取dom、脚本文件必须是线上文件、</p>
<h4 id="12、html和xhtml的区别"><a href="#12、html和xhtml的区别" class="headerlink" title="12、html和xhtml的区别"></a>12、html和xhtml的区别</h4><pre><code>xhtml语法更严格
a、元素语法
    XHTML 元素必须正确嵌套
    XHTML 元素必须始终关闭
    XHTML 元素必须小写
    XHTML 文档必须有一个根元素
b、属性语法
    XHTML 属性必须使用小写
    XHTML 属性值必须用引号包围
    XHTML 属性简写也是禁止的 错误：&lt;input checked&gt; 正确：&lt;input checked=&apos;checked&apos;&gt;
</code></pre><h4 id="13、css模块化"><a href="#13、css模块化" class="headerlink" title="13、css模块化"></a>13、css模块化</h4><pre><code>原因：CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。
解决方案：
1、声明独一无二的类名
2、CSS Modules
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">'react'</span>;</span><br><span class="line">import style from <span class="string">'./App.css'</span>;</span><br><span class="line">// App.jsx</span><br><span class="line"><span class="built_in">export</span> default () =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">        &lt;h1 className=&#123;style.title&#125;&gt;</span><br><span class="line">            Hello World</span><br><span class="line">        &lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line">// App.css </span><br><span class="line">.title &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">最终style.title会编译成哈希值</span><br></pre></td></tr></table></figure>
<pre><code>:global(.className)的语法，声明一个全局规则。凡是这样声明的class，都不会被编译成哈希字符串。
</code></pre><h4 id="14、响应式布局"><a href="#14、响应式布局" class="headerlink" title="14、响应式布局"></a>14、响应式布局</h4><pre><code>1、rem：如果没有在根元素指定参照值，那浏览器默认就是1rem为16px；如果你指定了值假设为20px，那1rem就为 20px。
2、flex
3、百分比布局
4、视口单位：vw、vh
5、media
    @media screen and (max-width: 414px) {
        body {
            background-color: blue;
        }
    }
</code></pre><h3 id="15、BFC-块级格式化上下文"><a href="#15、BFC-块级格式化上下文" class="headerlink" title="15、BFC 块级格式化上下文"></a>15、BFC 块级格式化上下文</h3><pre><code>具有BFC特性的元素可以看作是一个独立的容器，里面不会影响外面，外面不会影响里面
a、margin塌陷问题：一个容器里有一个div，父容器被撑高，给子元素设置margin-top, 父元素也跟着往下移
解决方案：1、父元素设置overflow：hidden 2、父元素设置边框
b、margin合并：上下两个div的margin间距取margin-bottom和margin-top中的大值,期望为margin-bottom和margin-top之和
解决方案：1、给两个div都套上一个div，并设置overflow：hidden 2、给div设置display：inline-block
</code></pre><h3 id="16、margin设置为百分比-是相对于父元素的宽度计算的"><a href="#16、margin设置为百分比-是相对于父元素的宽度计算的" class="headerlink" title="16、margin设置为百分比 是相对于父元素的宽度计算的"></a>16、margin设置为百分比 是相对于父元素的宽度计算的</h3><h2 id="五、React框架相关"><a href="#五、React框架相关" class="headerlink" title="五、React框架相关"></a>五、React框架相关</h2><h4 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h4><h4 id="2、代码分割"><a href="#2、代码分割" class="headerlink" title="2、代码分割"></a>2、代码分割</h4><pre><code>方法一：react的新特性
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;lazy, Suspense&#125; from <span class="string">'react'</span></span><br><span class="line">const LayoutPage = lazy(() =&gt; import(/* webpackChunkName: <span class="string">'Layout'</span> */ <span class="string">'layout/index.jsx'</span>))</span><br><span class="line">const Layout = <span class="keyword">function</span> (props) &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">            &lt;LayoutPage /&gt;</span><br><span class="line">        &lt;/Suspense&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

方法二：react-loadable
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Loadable from <span class="string">'react-loadable'</span>        </span><br><span class="line">const LayoutPage = Loadable(&#123;</span><br><span class="line">    loader: () =&gt; import(/* webpackChunkName: <span class="string">'Layout'</span> */ <span class="string">'layout/index.jsx'</span>)),</span><br><span class="line">    loading: &lt;div&gt;Loading...&lt;/div&gt;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

方法三：自定义方法实现
</code></pre><h4 id="3、组件深度嵌套时-从顶层组件向最内层组件传递数据-使用新版-Context-API"><a href="#3、组件深度嵌套时-从顶层组件向最内层组件传递数据-使用新版-Context-API" class="headerlink" title="3、组件深度嵌套时, 从顶层组件向最内层组件传递数据, 使用新版 Context API"></a>3、组件深度嵌套时, 从顶层组件向最内层组件传递数据, 使用新版 Context API</h4><pre><code>a: React.createContext 方法用于创建一个 Context 对象。该对象包含 Provider 和 Consumer两个属性，分别为两个 React 组件。
b: Provider 组件。用在组件树中更外层的位置。它接受一个名为 value 的 prop，其值可以是任何 JavaScript 中的数据类型。
c: Consumer 组件。可以在 Provider 组件内部的任何一层使用。它接收一个名为 children 值为一个函数的 prop。这个函数的参数是 Provider 组件接收的那个 value prop 的值，返回值是一个 React 元素（一段 JSX 代码）。
</code></pre><h4 id="4、Hooks"><a href="#4、Hooks" class="headerlink" title="4、Hooks"></a>4、Hooks</h4><pre><code>函数式组件
useState：状态变量
useEffect：把多个生命周期函数合并成一个，两个参数
自定义hook
useContext
useReducer
useMemo
useRef
</code></pre><p>hooks带来的好处：<br>1、组件可以拆分的更小，更容易复用代码<br>2、可以在函数式组件里使用state，及react新特性<br>3、代码量减少<br>hooks带来的缺陷：<br>1、状态不同步，情况：在异步回调中获取的变量是之前的值</p>
<h4 id="5、虚拟dom如何运行，fiber是什么"><a href="#5、虚拟dom如何运行，fiber是什么" class="headerlink" title="5、虚拟dom如何运行，fiber是什么"></a>5、虚拟dom如何运行，fiber是什么</h4><p>react 在内存中生成维护一个跟真实DOM一样的虚拟DOM 树<br>react生成真实dom的步骤如下(diff算法)：<br>1、state（数据）与模版结合生成虚拟dom。<br>2、React根据虚拟dom的结构生成真实dom节点（1）。<br>3、数据发生改变时，生成新的虚拟dom。<br>4、新的虚拟dom与原先的虚拟dom进行比较，根据diff算法，找到变更的部分，将其更新到真实dom上<br>新旧dom对比太耗性能，做出了如下限制<br>1、只对同级的节点进行对比，执行创建、删除、移动等操作，多跨级的节点只进行创建、删除操作<br>2、可以指定key，key不变组件则不更新，避免不必要的渲染</p>
<p>fiber是新出来的一种算法，把更新过程碎片化，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。</p>
<p>优点：最终真实DOM 就只更新了diff 部分，提高了渲染速度<br>缺点：首次渲染DOM 时候由于多了一层虚拟DOM 计算，就比html 渲染慢</p>
<h4 id="6、react事件系统和浏览器事件系统有什么区别"><a href="#6、react事件系统和浏览器事件系统有什么区别" class="headerlink" title="6、react事件系统和浏览器事件系统有什么区别"></a>6、react事件系统和浏览器事件系统有什么区别</h4><p>React 标准化了事件对象，和浏览器本地事件是是同一个接口( React 也就是把浏览器的事件包装了一把而已)，所以它可以工作在所有的浏览器中，可以直接在所有的浏览器使用 React 的事件。</p>
<p>一、React 事件和 HTML 事件<br>在 React 中绑定事件和 HTML 中绑定事件类似，但是还是有以下不同。<br>1、React 事件的命名是驼峰标志，比如: onClick 而不能是 onclick。<br>2、在 JSX 中你可以传一个方法去处理函数，而不是一个字符串。<br>3、React事件并没有原生的绑定在真实的DOM上，而是使用了 行为委托 方式实现事件机制。</p>
<h4 id="7、react-router原理"><a href="#7、react-router原理" class="headerlink" title="7、react-router原理"></a>7、react-router原理</h4><p>核心：history，一个JavaScript 库，可以管理会话历史记录。有跳转页面、浏览器前进、回退的api等，通过history.listen 可以监听路由变化</p>
<h4 id="8、组件库的按需加载"><a href="#8、组件库的按需加载" class="headerlink" title="8、组件库的按需加载"></a>8、组件库的按需加载</h4><p>借助babel-plugin-component插件 </p>
<h4 id="9、react不好的地方"><a href="#9、react不好的地方" class="headerlink" title="9、react不好的地方"></a>9、react不好的地方</h4><p>a、不要使用index当作key, 有时候会引起组件不渲染<br>b、不要使用Math.random()当作key, 每次都会渲染组件，比较耗性能<br>c、componentWillReceiveProps里面不要直接该state里的值，会一直重复渲染<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class HHH extends React.Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        arr: [&#123;</span><br><span class="line">            text: 1,</span><br><span class="line">            id: 1</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            text: 2,</span><br><span class="line">            id: 2</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            text: 3,</span><br><span class="line">            id: 3</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aa = () =&gt; &#123;</span><br><span class="line">        <span class="built_in">let</span> bb = this.state.arr</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            arr: bb.reverse()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">'station-data-monitor-page'</span>&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    this.state.arr.map((item, index) =&gt; &#123;</span><br><span class="line">                        <span class="built_in">return</span> (</span><br><span class="line">                            &lt;div key=&#123;index&#125;&gt;</span><br><span class="line">                                &lt;span&gt;&#123;item.text&#125;&lt;/span&gt;</span><br><span class="line">                                &lt;input <span class="built_in">type</span>=<span class="string">'text'</span> /&gt;</span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line">                        )</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                &lt;button onClick=&#123;this.aa&#125;&gt;&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 首先在input框里输入值，点击按钮时，input不会再重新渲染了，但是span里的值会变</span><br></pre></td></tr></table></figure></p>
<h2 id="六、webpack打包相关"><a href="#六、webpack打包相关" class="headerlink" title="六、webpack打包相关"></a>六、webpack打包相关</h2><h4 id="1、打包原理"><a href="#1、打包原理" class="headerlink" title="1、打包原理"></a>1、打包原理</h4><h4 id="2、background引用图片和img引用图片的区别"><a href="#2、background引用图片和img引用图片的区别" class="headerlink" title="2、background引用图片和img引用图片的区别"></a>2、background引用图片和img引用图片的区别</h4><pre><code>当我们要引用一个图片时，在js文件中要以引用它的html的路径为准；而在css文件中，要以该css的路径为准
</code></pre><p>参考文献<a href="https://www.jianshu.com/p/794c5f301169" title="Webpack打包图片路径问题" target="_blank" rel="noopener">Webpack打包图片路径问题</a></p>
<h4 id="3、contentBase"><a href="#3、contentBase" class="headerlink" title="3、contentBase"></a>3、contentBase</h4><pre><code>安装了html-webpack-plugin后, 此参数可不需要。
作用: 给浏览器访问的页面(虚拟文件)指定根目录, 默认访问html页面, 若没有html页面, 则看到所有文件(类似静态资源服务器)
前提：输出路径是dest, webpack文件在根目录下, 没有html页面
当启动webpack-dev-server的时候, 会在内存中创建dest文件, 在浏览器中访问可以看到跟目录下的所有文件; 
若设置contentBase为a, 在浏览器中访问可以看到a目录下的所有文件；
若有html页面, 则默认访问html页面,看不到所有文件。
</code></pre><h4 id="4、loader和plugin的区别"><a href="#4、loader和plugin的区别" class="headerlink" title="4、loader和plugin的区别"></a>4、loader和plugin的区别</h4><pre><code>loader是一个转换器，可以对文件进行编译、压缩等处理
plugin是一个扩展器，是在loader结束后运行，基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务。
</code></pre><h4 id="5、file-loader-和-url-loader-的区别"><a href="#5、file-loader-和-url-loader-的区别" class="headerlink" title="5、file-loader 和 url-loader 的区别"></a>5、file-loader 和 url-loader 的区别</h4><pre><code>url-loader强大之处：
1.文件大小小于limit参数，url-loader将会把文件转为DataURL；
2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。
因此我们只需要安装url-loader即可
</code></pre><h2 id="七、算法"><a href="#七、算法" class="headerlink" title="七、算法"></a>七、算法</h2><p>a、时间复杂度<br>时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。<br>b、空间复杂度<br>空间复杂度是指算法在计算机内执行时所需存储空间的度量。</p>
<h4 id="1、冒泡排序（比快速排序稳定）"><a href="#1、冒泡排序（比快速排序稳定）" class="headerlink" title="1、冒泡排序（比快速排序稳定）"></a>1、冒泡排序（比快速排序稳定）</h4><p>原理：对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小(降序)或最大(升序)的元素“浮”到顶端<br>对数子8、70、16、50、6、100、1进行排序<br>第一轮结果：8、16、50、6、70、1、100<br>第二轮结果：8、16、6、50、1、70、100<br>第三轮结果：8、16、6、1、50、70、100<br>第四轮结果：6、8、1、16、50、70、100<br>第五轮结果：6、1、8、16、50、70、100<br>第六轮结果：1、6、8、16、50、70、100<br>总结：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，时间复杂度 O（n²），即<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [8, 70, 16, 50, 6, 100, 1]</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i=0; i &lt; arr.length-1; i++) &#123;//外层循环控制排序趟数</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> j=0; j &lt; arr.length-1-i; j++) &#123;//内层循环控制每一趟排序多少次</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">            <span class="built_in">let</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+1];</span><br><span class="line">            arr[j+1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr) // 升序  [1, 6, 8, 16, 50, 70, 100]</span><br></pre></td></tr></table></figure></p>
<h4 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h4><p>原理：<br>    a、在数据集之中，选择一个元素作为”基准”（pivot）<br>　　b、所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边<br>    c、对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止<br>    时间复杂度 O（n log n)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var quickSort = <span class="keyword">function</span>(arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= 1) &#123;</span><br><span class="line">        <span class="built_in">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    // 从数组中间找出一个数作为基数</span><br><span class="line">    var pivotIndex = Math.floor(arr.length / 2)</span><br><span class="line">    var pivot = arr[pivotIndex];</span><br><span class="line"></span><br><span class="line">    // 存放小于基数的序列</span><br><span class="line">    var left = []</span><br><span class="line">    // 存放大于基数的序列</span><br><span class="line">    var right = []</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i !== pivotIndex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">                left.push(arr[i])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right.push(arr[i])</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> [...quickSort(left), pivot, ...quickSort(right)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3、二分查找（折半查找）"><a href="#3、二分查找（折半查找）" class="headerlink" title="3、二分查找（折半查找）"></a>3、二分查找（折半查找）</h4><p>作用：在一个有序数组中找出目标值所在的索引, 时间复杂度 O（log2n)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getIndex(target, arr, low, high) &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[low] === target) &#123;</span><br><span class="line">            <span class="built_in">return</span> low</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[high] === target) &#123;</span><br><span class="line">            <span class="built_in">return</span> high</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">let</span> midIndex = Math.ceil((low + high) / 2)</span><br><span class="line">        <span class="built_in">let</span> mid = arr [midIndex]</span><br><span class="line">        <span class="keyword">if</span> (target &lt; mid) &#123;</span><br><span class="line">            <span class="built_in">return</span> getIndex(target, arr, low, midIndex - 1)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; mid) &#123;</span><br><span class="line">            <span class="built_in">return</span> getIndex(target, arr, mid + 1, high)</span><br><span class="line">        &#125; ese &#123;</span><br><span class="line">            <span class="built_in">return</span> midIndex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> array = [1,5,7,10,45,90]</span><br><span class="line">getIndex(10, arr, 0, arr.length-1)</span><br></pre></td></tr></table></figure></p>
<h4 id="4、二叉树-前序遍历、中序遍历、后序遍历"><a href="#4、二叉树-前序遍历、中序遍历、后序遍历" class="headerlink" title="4、二叉树-前序遍历、中序遍历、后序遍历"></a>4、二叉树-前序遍历、中序遍历、后序遍历</h4><p>前序遍历：先遍历根节点、再左子树、再右子树<br>中序遍历：先左子树、再根节点、再右子树<br>后序遍历：先左子树、再右子树、再根节点</p>
<h2 id="k、js题"><a href="#k、js题" class="headerlink" title="k、js题"></a>k、js题</h2><h4 id="1、数组去重"><a href="#1、数组去重" class="headerlink" title="1、数组去重"></a>1、数组去重</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,1,2,3,4]</span><br><span class="line">1、[...new Set(arr)];</span><br><span class="line">2、_.uniq(arr);</span><br><span class="line">3、var newArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArr.includes(i)) &#123;</span><br><span class="line">        newArr.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、字符串转number"><a href="#2、字符串转number" class="headerlink" title="2、字符串转number"></a>2、字符串转number</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">'12'</span></span><br><span class="line">1、parseInt(str)、parseFloat(str)</span><br><span class="line">2、Number(str)</span><br><span class="line">3、str - 0</span><br><span class="line">4、_.toNumber(str)</span><br></pre></td></tr></table></figure>
<h4 id="3、-‘1’-‘2’-‘3’-map-parseInt"><a href="#3、-‘1’-‘2’-‘3’-map-parseInt" class="headerlink" title="3、[‘1’, ‘2’, ‘3’].map(parseInt)"></a>3、[‘1’, ‘2’, ‘3’].map(parseInt)</h4><pre><code>结果为：[1, NaN, NaN]
解析:
parseInt最终将字符串转为十进制
parseInt(&apos;1&apos;, 0)   // 结果1。radix为0, 基数为十进制
parseInt(&apos;2&apos;, 1)   // 结果NaN。2&lt;radix&lt;36 
parseInt(&apos;3&apos;, 2)   // 结果NaN。radix为2, 二进制只有0，1
</code></pre><h4 id="4、-‘1’-‘2’-‘3’-filter-parseInt"><a href="#4、-‘1’-‘2’-‘3’-filter-parseInt" class="headerlink" title="4、[‘1’, ‘2’, ‘3’].filter(parseInt)"></a>4、[‘1’, ‘2’, ‘3’].filter(parseInt)</h4><pre><code>结果为：[&apos;1&apos;]
解析:
parseInt最终将字符串转为十进制
parseInt(&apos;1&apos;, 0)   // 结果1。return true
parseInt(&apos;2&apos;, 1)   // 结果NaN。return false
parseInt(&apos;3&apos;, 2)   // 结果NaN。return false
</code></pre><h4 id="5、输出结果-如何解决"><a href="#5、输出结果-如何解决" class="headerlink" title="5、输出结果, 如何解决"></a>5、输出结果, 如何解决</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i=0;i&lt;10;i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i) // 结果: 10个10</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i) // 结果: 0、1、2、3、4、5、6、7、8、9</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> _func = <span class="keyword">function</span> (i) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            console.log(i) // 结果: 0、1、2、3、4、5、6、7、8、9</span><br><span class="line">        &#125;, 0)</span><br><span class="line">    &#125;</span><br><span class="line">    _func(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(</span><br><span class="line">        <span class="keyword">function</span> timer(i) &#123;</span><br><span class="line">            console.log(i) // 结果: 0、1、2、3、4、5、6、7、8、9</span><br><span class="line">    &#125;, 0, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、数组拍平"><a href="#6、数组拍平" class="headerlink" title="6、数组拍平"></a>6、数组拍平</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, [3, 4, [5, 6]]]</span><br><span class="line"><span class="built_in">let</span> newArr = arr6.toString().split(<span class="string">','</span>).map(item =&gt; parseInt(item)) // [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr2 = [1, 2, [3, 4]]</span><br><span class="line"><span class="built_in">let</span> newArr2 = arr2.toString().split(<span class="string">','</span>).map(item =&gt; parseInt(item)) // [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> newArr3 = []</span><br><span class="line"><span class="keyword">function</span> flat(arr) &#123;</span><br><span class="line">    arr.map(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Array.isArray(item)) &#123;</span><br><span class="line">            flat(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newArr3.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">flat(arr); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<h4 id="7、把数组顺序打乱"><a href="#7、把数组顺序打乱" class="headerlink" title="7、把数组顺序打乱"></a>7、把数组顺序打乱</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"><span class="keyword">function</span> randomsort(a, b) &#123;</span><br><span class="line">    <span class="built_in">return</span> Math.random()&gt;.5 ? -1 : 1;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.sort(randomsort);</span><br></pre></td></tr></table></figure>
<h4 id="8、判断输出值"><a href="#8、判断输出值" class="headerlink" title="8、判断输出值"></a>8、判断输出值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">一、</span><br><span class="line">typeof typeof 1; // typeof 1 -&gt; <span class="string">'number'</span>; typeof <span class="string">'number'</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof <span class="string">'12dfd'</span>; //  typeof <span class="string">'12dfd'</span> -&gt; <span class="string">'string'</span>; typeof <span class="string">'string'</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof <span class="literal">true</span>; // typeof <span class="literal">true</span> -&gt; <span class="string">"boolean"</span>; typeof <span class="string">"boolean"</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof null; // typeof null -&gt; <span class="string">"object"</span>; typeof <span class="string">"object"</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof undefined; // typeof undefined -&gt; <span class="string">"undefined"</span>; typeof <span class="string">"undefined"</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof [1,2,3]; // typeof [1,2,3] -&gt; <span class="string">"object"</span>; typeof <span class="string">"object"</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof &#123;&#125;; // typeof &#123;&#125; -&gt; <span class="string">"object"</span>; typeof <span class="string">"object"</span> -&gt; <span class="string">"string"</span></span><br><span class="line"></span><br><span class="line">二、</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var a = b = 5;</span><br><span class="line">&#125;())</span><br><span class="line">console.log(a); // 报错</span><br><span class="line">console.log(b); // 5</span><br><span class="line">解析：变量b没有用var声明, 所以是全局的, 挂载在window上; 变量a用var声明了, 是私有变量, 只能在函数中获取</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var a = b = 5;</span><br><span class="line">    console.log(a); // 5</span><br><span class="line">    console.log(b); // 5</span><br><span class="line">&#125;())</span><br><span class="line">解析：变量b没有用var声明, 是全局的; 变量a用var声明了, 是私有变量; 函数内可以访问外部的变量</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangyang158.github/2019/10/10/问题总结/" data-id="ckgujwhrk000owsuv15xszh5c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/30/微信公众号/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          微信公众号
        
      </div>
    </a>
  
  
    <a href="/2019/09/29/搭建静态服务器/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">搭建静态服务器</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/01/框架/">框架</a>
          </li>
        
          <li>
            <a href="/2020/08/14/promise/">promise</a>
          </li>
        
          <li>
            <a href="/2020/06/12/开机自启动脚本/">开机自启动脚本</a>
          </li>
        
          <li>
            <a href="/2020/06/08/小程序/">小程序</a>
          </li>
        
          <li>
            <a href="/2020/06/03/javascript页面容错处理/">javascript页面容错处理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Candy<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>