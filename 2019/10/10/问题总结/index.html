<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>问题总结 | 学无止境</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、原生js基础相关变量区分大小写1、数据类型有哪些基本数据类型(存放在栈中)：string、number、boolean、null、undefined、symbol 引用类型(存放在堆中)：object、function 注意1: 栈和堆的区别    栈（stack）为自动分配的内存空间, 它由系统自动释放; 而堆（heap）则是动态分配的内存, 大小不定也不会自动释放注意2: null和und">
<meta property="og:type" content="article">
<meta property="og:title" content="问题总结">
<meta property="og:url" content="http://yoursite.com/2019/10/10/问题总结/index.html">
<meta property="og:site_name" content="学无止境">
<meta property="og:description" content="一、原生js基础相关变量区分大小写1、数据类型有哪些基本数据类型(存放在栈中)：string、number、boolean、null、undefined、symbol 引用类型(存放在堆中)：object、function 注意1: 栈和堆的区别    栈（stack）为自动分配的内存空间, 它由系统自动释放; 而堆（heap）则是动态分配的内存, 大小不定也不会自动释放注意2: null和und">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-06-04T08:28:05.512Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="问题总结">
<meta name="twitter:description" content="一、原生js基础相关变量区分大小写1、数据类型有哪些基本数据类型(存放在栈中)：string、number、boolean、null、undefined、symbol 引用类型(存放在堆中)：object、function 注意1: 栈和堆的区别    栈（stack）为自动分配的内存空间, 它由系统自动释放; 而堆（heap）则是动态分配的内存, 大小不定也不会自动释放注意2: null和und">
  
    <link rel="alternate" href="/atom.xml" title="学无止境" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">学无止境</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-问题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/10/问题总结/" class="article-date">
  <time datetime="2019-10-10T01:32:48.000Z" itemprop="datePublished">2019-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      问题总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、原生js基础相关"><a href="#一、原生js基础相关" class="headerlink" title="一、原生js基础相关"></a>一、原生js基础相关</h2><h4 id="变量区分大小写"><a href="#变量区分大小写" class="headerlink" title="变量区分大小写"></a>变量区分大小写</h4><h4 id="1、数据类型有哪些"><a href="#1、数据类型有哪些" class="headerlink" title="1、数据类型有哪些"></a>1、数据类型有哪些</h4><pre><code>基本数据类型(存放在栈中)：string、number、boolean、null、undefined、symbol
引用类型(存放在堆中)：object、function
</code></pre><p><strong>注意1:</strong> 栈和堆的区别<br>    栈（stack）为自动分配的内存空间, 它由系统自动释放; 而堆（heap）则是动态分配的内存, 大小不定也不会自动释放<br><strong>注意2:</strong> null和undefined的区别<br>    typeof undefined   // undefined<br>    typeof null        // object<br>    null === undefined // false<br>    null == undefined  // true</p>
<h4 id="2、如何判断数据的类型"><a href="#2、如何判断数据的类型" class="headerlink" title="2、如何判断数据的类型"></a>2、如何判断数据的类型</h4><pre><code>typeof 可以正确的判断基本数据类型的类型, 但是对于对象, 都是object, 对于函数都是function
Object.prototype.toString.call(param) 可以判断基本数据类型和引用数据类型的类型
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeof [] === <span class="string">'object'</span></span><br><span class="line">typeof &#123;&#125; === <span class="string">'object'</span></span><br><span class="line">typeof alert === <span class="string">'function'</span></span><br><span class="line">typeof null === <span class="string">'object'</span> (一个存在很久的bug)</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // <span class="string">"[object Object]"</span></span><br><span class="line">Object.prototype.toString.call([])  // <span class="string">"[object Array]"</span></span><br></pre></td></tr></table></figure>
</code></pre><h4 id="3、判断是不是某构造函数的实例"><a href="#3、判断是不是某构造函数的实例" class="headerlink" title="3、判断是不是某构造函数的实例"></a>3、判断是不是某构造函数的实例</h4><pre><code>instanceof：通过原型链判断
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person (name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> p1 = new Person(<span class="string">'张三'</span>)</span><br><span class="line">p1 instanceof Person // <span class="literal">true</span> p1是构造函数Person的实例</span><br><span class="line">Person[Symbol.hasInstance](p1) // <span class="literal">true</span> 与上面等价</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="4、等号赋值、浅拷贝、深拷贝的区别"><a href="#4、等号赋值、浅拷贝、深拷贝的区别" class="headerlink" title="4、等号赋值、浅拷贝、深拷贝的区别"></a>4、等号赋值、浅拷贝、深拷贝的区别</h4><p><a href="https://www.haorooms.com/post/js_copy_sq" target="_blank" rel="noopener">https://www.haorooms.com/post/js_copy_sq</a><br>等号赋值：新数据和原数据指向同一引用<br>浅拷贝：新数据和原数据不指向同一个引用, 如果原数据里包含子对象, 新旧子对象共享同一块内存<br>深拷贝：会另外创造一个一模一样的对象, 新对象跟原对象不共享内存, 修改新对象不会改到原对象<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#####浅拷贝的实现方式:</span></span><br><span class="line"></span><br><span class="line">第一种：lodash的方法_.cclone</span><br><span class="line">第二种：...  注意：必须含有子对象</span><br><span class="line">第三种：Object.assgin(), 注意：obj里必须含有子对象</span><br><span class="line">var obj = &#123; a: &#123;msg: <span class="string">"hello"</span>, num: 21&#125;, b:3 &#125;;</span><br><span class="line">var cloneObj = Object.assign(&#123;&#125;, obj);</span><br><span class="line">obj === cloneObj; // <span class="literal">false</span></span><br><span class="line">obj.a.num = 66;</span><br><span class="line">obj.b = 10;</span><br><span class="line">console.log(cloneObj.a.num); // 66</span><br><span class="line">console.log(cloneObj.b); // 3</span><br><span class="line">第四种：自定义方法</span><br><span class="line"><span class="keyword">function</span> shallowClone(initalObj) &#123;    </span><br><span class="line">    var obj = &#123;&#125;;    </span><br><span class="line">    <span class="keyword">for</span> ( var i <span class="keyword">in</span> initalObj) &#123;</span><br><span class="line">        obj[i] = initalObj[i];</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: <span class="string">"hello"</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        a: <span class="string">"world"</span>,</span><br><span class="line">        b: 21</span><br><span class="line">    &#125;,</span><br><span class="line">    c: [<span class="string">"Bob"</span>, <span class="string">"Tom"</span>, <span class="string">"Jenny"</span>],</span><br><span class="line">    d: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        alert(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var cloneObj = shallowClone(obj); </span><br><span class="line">cloneObj === obj; // <span class="literal">false</span></span><br><span class="line">// 新数据和原数据的b、c、d指向同一引用</span><br><span class="line">cloneObj.b.a = <span class="string">"changed"</span>; // obj和cloneObj都改变</span><br><span class="line">cloneObj.c[0] = 6; // obj和cloneObj都改变</span><br><span class="line">cloneObj.d = <span class="function"><span class="title">function</span></span>() &#123; alert(<span class="string">"changed"</span>); &#125; // obj的d属性不改变</span><br><span class="line"></span><br><span class="line"><span class="comment">#####深拷贝的实现方式:</span></span><br><span class="line">第一种：用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象</span><br><span class="line">第二种：对象只有一层的话可以使用上面的：Object.assign()函数</span><br><span class="line">第三种：...  注意：不能含有子对象</span><br><span class="line">第四种：lodash的_.cloneDeep</span><br><span class="line">第五种：自定义方法，递归拷贝</span><br><span class="line">//  使用递归的方式实现数组、对象的深拷贝</span><br><span class="line"><span class="keyword">function</span> deepClone(obj) &#123;</span><br><span class="line">    //判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝</span><br><span class="line">    var objClone = Array.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line">    //进行深拷贝的不能为空，并且是对象或者是</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; typeof obj === <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obj[key] &amp;&amp; typeof obj[key] === <span class="string">"object"</span>) &#123;</span><br><span class="line">                    objClone[key] = deepClone1(obj[key])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    objClone[key] = obj[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line">deepClone(&#123;name: <span class="string">'yy'</span>, age: 12, obj: &#123;color: <span class="string">'res'</span>, big: <span class="literal">true</span>&#125;, arr: [1, 2, 3]&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="5、什么是闭包-闭包的作用-为什么要使用闭包"><a href="#5、什么是闭包-闭包的作用-为什么要使用闭包" class="headerlink" title="5、什么是闭包, 闭包的作用, 为什么要使用闭包"></a>5、什么是闭包, 闭包的作用, 为什么要使用闭包</h4><pre><code>匿名函数本身也是一个闭包
闭包：函数A里面有一个函数B, 函数B可以访问到函数A里面的局部变量, 函数B就是闭包
本质：闭包是将函数内部和函数外部连接起来的桥梁
作用：1、可以读取函数内部的变量 2、让一些变量始终保持在内存中
为什么要使用闭包：在函数外部无法读取函数内部的局部变量, 如果想要获取, 可以在函数里在声明一个函数
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 想要在函数外部获取f1里面的变量n, 所以需要在f1里声明一个f2, 并作为返回值</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">    var n = 999;</span><br><span class="line">    nAdd = <span class="function"><span class="title">function</span></span>() &#123;n += 1&#125;; // 没用var声明, 则是全局变量</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>()&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> f2; // f2就是闭包</span><br><span class="line">&#125;</span><br><span class="line">var result = f1();</span><br><span class="line">result(); // 999</span><br><span class="line">nAdd();</span><br><span class="line">result(); // 1000</span><br></pre></td></tr></table></figure>
<p>1、首先函数f1执行后将f2赋给了全局变量result，所以f2始终在内存中，函数f2在函数f1内部，所以在f2的内部可以访问到f1的变量n。<br>2、因为f2的存在依赖了f1中的变量n，所以使得f1也始终被存储在了内存中，在调用之后，不会被垃圾回收机制回收。（内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被释放,因为闭包需要它们）</p>
<h4 id="6、构造函数和继承"><a href="#6、构造函数和继承" class="headerlink" title="6、构造函数和继承"></a>6、构造函数和继承</h4><pre><code>构造函数作用：需要大批量的创建对象的时候，就需要用到构造函数，它可以方便创建多个对象的实例
A为父类, 在子类B的构造函数里调用父类的构造函数，拷贝一份父类的原型 作为 子类的原型
实例化new 的过程中会发生以上四件事情：
    a、新生成了一个对象
    b、链接到原型
    c、绑定 this
    d、返回新对象
</code></pre><h4 id="7、什么是原型？什么是原型链"><a href="#7、什么是原型？什么是原型链" class="headerlink" title="7、什么是原型？什么是原型链"></a>7、什么是原型？什么是原型链</h4><pre><code>构造函数的prototype属性指向原型,原型的constructor属性指回构造函数,实例的_proto_指向原型。
所有实例共享原型上的属性和方法
</code></pre><h4 id="8、浏览器端缓存"><a href="#8、浏览器端缓存" class="headerlink" title="8、浏览器端缓存"></a>8、浏览器端缓存</h4><pre><code>cookie：与服务器端通信,每次都会携带在HTTP头中。cookie的长度和数量受限制,每个domain最多只能有20条cookie,每个cookie长度不能超过4KB。否则会被截掉。
sessionStorage: 仅在当前会话下有效,关闭页面或浏览器后被清除,存放数据大小为一般为5MB,在客户端中保存,不参与和服务器的通信
localStorage：存放数据大小为一般为5MB,在客户端中保存,不参与和服务器的通信
</code></pre><h4 id="9、同步和异步、并发和并行、线程和多线程和单线程、进程"><a href="#9、同步和异步、并发和并行、线程和多线程和单线程、进程" class="headerlink" title="9、同步和异步、并发和并行、线程和多线程和单线程、进程"></a>9、同步和异步、并发和并行、线程和多线程和单线程、进程</h4><pre><code>并行: 同一时刻发生两个或者多个事件。比如：并行：你吃饭吃到一半, 电话来了, 你一边打电话一边吃饭
并发: 同一时科两个或多个事件在间隔发生。比如：你吃饭吃到一半, 电话来了, 你停了下来接了电话, 接完后继续吃饭

进程: 当一个程序开始运行时, 它就是一个进程, 一个进程又是由多个线程所组成的
多线程: 一个程序中可以同时运行多个不同的线程
单线程: 一个程序中只有一个线程

同步：A请求回来了再发B请求
异步：A请求和B请求可以同时发
</code></pre><h4 id="10、for循环有哪些方法及区别"><a href="#10、for循环有哪些方法及区别" class="headerlink" title="10、for循环有哪些方法及区别"></a>10、for循环有哪些方法及区别</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [2,4,1,5,7]</span><br><span class="line">arr.length= 5</span><br><span class="line"><span class="built_in">let</span> obj = &#123;name: <span class="string">'张三'</span>, age: 12&#125;</span><br><span class="line"><span class="built_in">let</span> str = <span class="string">'abcdefg123'</span></span><br><span class="line">// 支持数组、字符串</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i=0;i&lt;=str.length-1;i++) &#123;</span><br><span class="line">    console.log(i, arr[i]) // i是索引</span><br><span class="line">&#125;</span><br><span class="line">//  支持数组、字符串、对象</span><br><span class="line">// 缺点(针对数组)：可以将属性打印出来</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    console.log(i, arr[i]) // i是索引0,1,2,3,4,length</span><br><span class="line">&#125;</span><br><span class="line">//  支持数组、字符串(es6提出,解决<span class="keyword">for</span>-in的缺陷, 只返回具有数字索引的属性)</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of arr) &#123;</span><br><span class="line">    console.log(value) // value 是值, 不是索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11、箭头函数和普通函数的this指向"><a href="#11、箭头函数和普通函数的this指向" class="headerlink" title="11、箭头函数和普通函数的this指向"></a>11、箭头函数和普通函数的this指向</h4><pre><code>箭头函数：如果包裹在函数中, 只取决包裹箭头函数的第一个普通函数的this
普通函数：this由函数调用时决定
</code></pre><h4 id="12、break、continue、return的区别"><a href="#12、break、continue、return的区别" class="headerlink" title="12、break、continue、return的区别"></a>12、break、continue、return的区别</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">myBreak</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(var j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">        console.log(<span class="string">'j'</span>, j)</span><br><span class="line">        <span class="keyword">for</span>(var i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == 2) &#123;</span><br><span class="line">                <span class="built_in">break</span>; // j:0,i:0,i:1;j:1,i:0,i:1;j:2,i:0,i:1</span><br><span class="line">                <span class="built_in">continue</span>; // j:0,i:0,i:1,i:3;j:1,i:0,i:1,i:3;j:2,i:0,i:1,i:3</span><br><span class="line">                <span class="built_in">return</span>; // j:0,i:0,i:1</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(<span class="string">'i'</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myBreak();</span><br></pre></td></tr></table></figure>
<pre><code>break: 跳出当前循环(如果嵌套多层循环, 只能跳出当前一层循环)
continue: 用于跳过当次循环, 还会继续循环
return: 结束函数的调用
</code></pre><h4 id="13、forEach、map、filter的区别"><a href="#13、forEach、map、filter的区别" class="headerlink" title="13、forEach、map、filter的区别"></a>13、forEach、map、filter的区别</h4><pre><code>forEach: 只是简单的将数组遍历, 不会改变原数组, 没有返回值
map: 方法里有return的话, 会返回新数组, 不会改变原数组; 也可以直接处理每一项的值, 会改变原数组 
filter: 使用return, 返回满足条件的新数组, 不会改变原数组
</code></pre><h4 id="14、字符串、数组、数字有哪些方法"><a href="#14、字符串、数组、数字有哪些方法" class="headerlink" title="14、字符串、数组、数字有哪些方法"></a>14、字符串、数组、数字有哪些方法</h4><pre><code>String对象方法：concat、indexOf、lastIndexOf、split、slice、substring、substr、toLowerCase、toUpperCase、trim、replace、toString、valueOf
Array对象方法：concat、join、indexOf、lastIndexOf、slice、splice、push、pop、shift、unshift、reverse、includes、reduce、find、findIndex、map、filter、forEach、some、isArray、sort、toString、valueOf
Number对象方法：toFixed、toString、valueOf
Boolean 对象方法：toString、valueOf
注意数组的sort方法:
sort()并不是按照数值进行排序，而是按字符串字母的ASCII码值进行比较排序的，所以当数组项为数字时，sort()也会自动先将数字转换成字符串，然后再按字母比较的规则进行排序处理。
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [8, 70, 16, 50, 6, 100, 1];</span><br><span class="line"><span class="keyword">function</span> compare (a, b) &#123;</span><br><span class="line">    console.log(a, b)</span><br><span class="line">    <span class="built_in">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> result = arr.sort(compare)</span><br><span class="line">console.log(<span class="string">'result'</span>, result) // 升序： [1, 6, 8, 16, 50, 70, 100]</span><br></pre></td></tr></table></figure>
<h4 id="15、什么是对象-面向对象和面向过程的区别"><a href="#15、什么是对象-面向对象和面向过程的区别" class="headerlink" title="15、什么是对象, 面向对象和面向过程的区别"></a>15、什么是对象, 面向对象和面向过程的区别</h4><pre><code>对象：拥有属性和方法的集合。在js里一切皆对象, 小轿车就是一个对象, 拥有轮胎、窗等属性, 方法有启动停止等
面向对象：封装, 继承, 多态的特点。碰到相同的问题可以直接调用
面向过程：分析出解决问题所需要的步骤, 然后用函数把这些步骤一步一步实现
举例：洗碗
面向过程：先把碗放到水池里 -&gt; 放水 -&gt; 倒洗洁精 -&gt; 用抹布洗 -&gt; 冲洗 -&gt; 拿出来晾干
面向对象：封装一个洗碗机
</code></pre><h4 id="16、长连接"><a href="#16、长连接" class="headerlink" title="16、长连接"></a>16、长连接</h4><pre><code>websocket：服务端主动向客户端推送消息
let w1 = new WebSocket(SOCKETURL)
onopen(): 连接成功
onmesage(): 接受消息
close(): 关闭连接
</code></pre><p><strong>注：</strong> 使用Nginx代理WebSocket,如果在60秒(默认)内没有数据交互,就会自动断开连接</p>
<h4 id="17、js的三种类型转换"><a href="#17、js的三种类型转换" class="headerlink" title="17、js的三种类型转换"></a>17、js的三种类型转换</h4><pre><code>转换为布尔值、转换为数字、转换为字符串
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">原始值值类型</th>
<th style="text-align:left">转换目标</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left">除了’’, 其余都是true</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left">除了0、-0、NaN, 其余都是true</td>
</tr>
<tr>
<td style="text-align:left">null、undefined</td>
<td style="text-align:left">布尔值</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">number、symbol</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">5 =&gt; ‘5’、String(Symbol()) =&gt; “Symbol()”</td>
</tr>
<tr>
<td style="text-align:left">function</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">String(function getName () {}) =&gt; “function getName () {}”</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">true =&gt; ‘true’、false =&gt; ‘false’</td>
</tr>
<tr>
<td style="text-align:left">数组</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">[] =&gt; ‘’、[1, 2] =&gt; ‘1,2’</td>
</tr>
<tr>
<td style="text-align:left">对象</td>
<td style="text-align:left">字符串</td>
<td style="text-align:left">“[object Object]”</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">‘’ =&gt; 0、’1’ =&gt; 1、’2sdsd’ =&gt; NaN</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">false =&gt; 0、true =&gt; 1</td>
</tr>
<tr>
<td style="text-align:left">数组</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">[] =&gt; 0、[1] =&gt; 1、[1,2] =&gt; NaN</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">undefined、除了数组的引用类型</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">NaN</td>
</tr>
<tr>
<td style="text-align:left">symbol</td>
<td style="text-align:left">数字</td>
<td style="text-align:left">报错</td>
</tr>
</tbody>
</table>
<h4 id="18、浅比较和深比较的区别"><a href="#18、浅比较和深比较的区别" class="headerlink" title="18、浅比较和深比较的区别"></a>18、浅比较和深比较的区别</h4><p>浅比较：判断2个对象的引用地址是否一样<br>深比较：判断2个对象的所有属性值是否一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 浅比较</span><br><span class="line">const obj1 = &#123;age: 12&#125;</span><br><span class="line">const obj2 = &#123;age: 12&#125;</span><br><span class="line">const obj3 = obj1</span><br><span class="line">obj1 === obj2; // <span class="literal">false</span></span><br><span class="line">obj3 === obj1; // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="19、栈、堆、队列"><a href="#19、栈、堆、队列" class="headerlink" title="19、栈、堆、队列"></a>19、栈、堆、队列</h4><p>栈: 先进后出的有序集合，js的基本数据类型都存放在栈中，栈由编译器自动分配释放，调用完毕自动释放。<br>堆：一般由操作人员（程序员）分配释放，若操作人员不分配释放，将由OS回收释放，js的引用数据类型都存放在堆中<br>队列：先进先出的有序集合<br><strong>为什么会有堆内存、栈内存之分？</strong><br>通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。<br>当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；<br>当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。</p>
<h4 id="20、JavaScript-运行机制"><a href="#20、JavaScript-运行机制" class="headerlink" title="20、JavaScript 运行机制"></a>20、JavaScript 运行机制</h4><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" title="阮一峰" target="_blank" rel="noopener">参考文献</a></p>
<p><strong>宏任务、微任务</strong><br>宏任务：可以理解是每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)。主要场景有：主代码块script、setTimeout、setInterval等<br>微任务：可以理解是在当前task执行结束后立即执行的任务。主要场景有：Promise、process.nextTick等。<br><strong>运行机制</strong><br>js是单线程，分为同步任务和异步任务<br>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。(事件循环)<br>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>
<h4 id="21、防抖和节流：减少不必要的损耗"><a href="#21、防抖和节流：减少不必要的损耗" class="headerlink" title="21、防抖和节流：减少不必要的损耗"></a>21、防抖和节流：减少不必要的损耗</h4><p>防抖：动作触发后间隔一段时间 触发某个事件，如果在这段时间内又触发了该动作，则从此刻起 计算间隔时间<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> debounce(fn, time) &#123;</span><br><span class="line">    <span class="built_in">let</span> timerId: any = null</span><br><span class="line">    <span class="built_in">return</span> () =&gt; &#123;</span><br><span class="line">        clearTimeout(timerId)</span><br><span class="line">        timerId = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn(<span class="string">'yy'</span>, 12)</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sayHello</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'test'</span>, arguments)</span><br><span class="line">&#125;</span><br><span class="line">// 效果: 点击一个按钮, 4秒后触发sayHello函数</span><br><span class="line"><span class="built_in">let</span> btn: any = document.querySelector(<span class="string">'.tets'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, debounce(sayHello, 4000))</span><br></pre></td></tr></table></figure></p>
<p>节流：动作触发后间隔一段时间 触发某个事件，如果在这段时间内又触发了该动作，则无视该动作<br>例如：8s内无论重复触发多少次该动作，都只触发一次该事件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> throtte(fn, time) &#123;</span><br><span class="line">    <span class="built_in">let</span> preTime = 0</span><br><span class="line">    <span class="built_in">return</span> () =&gt; &#123;</span><br><span class="line">        // 时间戳</span><br><span class="line">        <span class="built_in">let</span> now = Date.now()</span><br><span class="line">        <span class="keyword">if</span> (now - preTime &gt; time) &#123;</span><br><span class="line">            fn()</span><br><span class="line">            preTime = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>  <span class="function"><span class="title">sayHello</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'节流'</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 效果: 重复点击一个按钮, 8秒后只会触发一次sayHello函数</span><br><span class="line"><span class="built_in">let</span> btn: any = document.querySelector(<span class="string">'.tets'</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, this.throtte(this.sayHello, 8000))</span><br></pre></td></tr></table></figure></p>
<h5 id="22、JavaScript设计模式"><a href="#22、JavaScript设计模式" class="headerlink" title="22、JavaScript设计模式"></a>22、JavaScript设计模式</h5><pre><code>单例模式：保证一个类只有一个实例
工厂模式：构造函数
发布-订阅模式：addEventListener
装饰者模式：给对象动态添加属性和方法
</code></pre><h5 id="23、JavaScript架构模式"><a href="#23、JavaScript架构模式" class="headerlink" title="23、JavaScript架构模式"></a>23、JavaScript架构模式</h5><pre><code>MVC: 数据层 + 视图层 + 控制器
MVP: 数据层 + 视图层 + 展示器
MVVM: Model + View + ViewModel, 是基于MVC和MVP的架构模式, Angular、Vue
</code></pre><h5 id="24、script异步加载的方法"><a href="#24、script异步加载的方法" class="headerlink" title="24、script异步加载的方法"></a>24、script异步加载的方法</h5><pre><code>1、script标签的defer属性：页面渲染 和 脚本的加载 并行执行， 脚本的执行需要等所有元素解析完成后
2、script标签的async属性: 页面渲染 和 脚本的加载、执行 并行执行 ---html5提出
3、script标签设置type=&quot;module&quot;, 类似defer
4、动态创建script脚本
</code></pre><h2 id="二、ajax请求相关"><a href="#二、ajax请求相关" class="headerlink" title="二、ajax请求相关"></a>二、ajax请求相关</h2><h4 id="1、post和get的区别"><a href="#1、post和get的区别" class="headerlink" title="1、post和get的区别"></a>1、post和get的区别</h4><pre><code>post：url在body体中, url长度限制是特定的浏览器及服务器对它的限制
get：参数拼接在url上, 出于安全考虑, 服务器端在实现时会做一定限制, nginix默认限制1M, Tomcat 默认是2M
</code></pre><p><strong>注意1:</strong> HTTP 协议规范没有对 get和post的URL 长度进行限制<br><strong>注意2:</strong> 不同浏览器对url长度的限制<br>IE: 2803<br>Firefox: 65536<br>Chrome: 8182<br>Safari: 80000<br>Opera: 190000</p>
<h4 id="2、什么是跨域-跨域有哪些解决方法"><a href="#2、什么是跨域-跨域有哪些解决方法" class="headerlink" title="2、什么是跨域, 跨域有哪些解决方法"></a>2、什么是跨域, 跨域有哪些解决方法</h4><pre><code>跨域：协议、ip、端口号 有一个不一样就是跨域
解决方案：
1、postMessage进行信息传递, HTML5的新api, 可以在不同的iframe之间传递消息
2、CORS：只需服务端设置Access-Control-Allow-Origin即可, 若要带cookie请求, 前后端都需要设置
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加<span class="string">'/'</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://www.domain1.com"</span>); </span><br><span class="line">// 允许前端带认证cookie：启用此项后，上面的域名不能为<span class="string">'*'</span>，必须指定具体的域名，否则浏览器会提示</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>); </span><br><span class="line">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type,X-Requested-With"</span>);</span><br></pre></td></tr></table></figure>
<pre><code>3、JSONP, 借助script标签
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 请求地址后面加一个callback=函数名, 后台返回 函数名(<span class="string">'我请求到了'</span>), 就能调用到该函数</span><br><span class="line">    var script = document.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    window.showData = <span class="keyword">function</span>(res)&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">'http://192.168.141.210:7310/api/home/cardList?callback=showData'</span>;</span><br><span class="line">    document.head.appendChild(script);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">koa 模拟后端处理</span><br><span class="line">@get(<span class="string">'/home/cardList'</span>)</span><br><span class="line">async GetCardeList(ctx)&#123;</span><br><span class="line">    // 获取请参参数</span><br><span class="line">    <span class="built_in">let</span> func = ctx.query.callback</span><br><span class="line">    // 复杂的响应</span><br><span class="line">    ctx.body = func + `(<span class="variable">$&#123;JSON.stringify(['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'])&#125;</span>)`</span><br><span class="line">    // 简单的响应</span><br><span class="line">    ctx.body = func + `(<span class="string">'哈哈哈哈'</span>)`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>4、后端不存在跨域, 让后端处理
5、借助无跨域的标签，比如img、script
6、设置domain
两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共Cookie。
举例来说，A网站是:http:weibo.qq.com，B网站是:http:lol.qq.com，只需设置document.domain=&apos;qq.com&apos;,两个网页就可共享Cookie。
</code></pre><h5 id="4、两个tab之间进行通信"><a href="#4、两个tab之间进行通信" class="headerlink" title="4、两个tab之间进行通信"></a>4、两个tab之间进行通信</h5><pre><code>1、两个打开的tab页面属于同源范畴
    localStorage、sessionStorage、Cookie
2、完全没有关系的两个浏览器的tab通信
    A、B Tab 引入iframe 并且指向同一个页面, 利用postMessage通信
</code></pre><h2 id="二、性能优化相关"><a href="#二、性能优化相关" class="headerlink" title="二、性能优化相关"></a>二、性能优化相关</h2><h4 id="1、如何优化性能"><a href="#1、如何优化性能" class="headerlink" title="1、如何优化性能"></a>1、如何优化性能</h4><pre><code>a、DNS预解析（不能滥用）
    eg：
    // 开启预解析
    &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;
    // 关闭预解析
    &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt;
    // link的设置会让浏览器预取&quot;www.zhix.net&quot;的解析
    &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.zhix.net&quot;&gt;
b、http缓存
c、CDN加速-适合处理静态文件
    原理：把内容发布到世界的各个节点，用户可以在距离最近的网络节点获取到内容, 减少网络传输距离达到加速的目的
b、代码层面
    1) 防抖、节流
    2) 减少http请求次数
        合并文件、css雪碧图
    3) js、css、图片等资源进行压缩
    4) 减少操作频繁DOM
    5) 图片预加载、懒加载
</code></pre><h2 id="三、es6-ES2017-相关"><a href="#三、es6-ES2017-相关" class="headerlink" title="三、es6(ES2017)相关"></a>三、es6(ES2017)相关</h2><h4 id="1、let、var、const声明变量"><a href="#1、let、var、const声明变量" class="headerlink" title="1、let、var、const声明变量"></a>1、let、var、const声明变量</h4><pre><code>let：声明的变量不能再重新声明, 可以修改值
const：声明的变量不能再重新声明, 如果是基本数据类型, 则不能修改值, 引用类型, 可以改
let、const 在全局声明的变量 不会挂载到window上
var：变量可以声明多次, 后面的会替代前面的(存在变量提升),
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(name) // <span class="string">''</span></span><br><span class="line">console.log(name2) // 报错</span><br><span class="line">getName() // name的值 <span class="string">''</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getName</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'name的值'</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">var name = <span class="string">'张三'</span></span><br><span class="line">getName() // name的值 张三</span><br><span class="line"><span class="built_in">let</span> name2 = <span class="string">'李四'</span></span><br></pre></td></tr></table></figure>
<h4 id="2、什么是类-类的继承"><a href="#2、什么是类-类的继承" class="headerlink" title="2、什么是类, 类的继承"></a>2、什么是类, 类的继承</h4><pre><code>class 、extends
</code></pre><h4 id="3、Promise"><a href="#3、Promise" class="headerlink" title="3、Promise"></a>3、Promise</h4><pre><code>Promise是异步编程的一种解决方案, 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> myPromise = new Promise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">    <span class="keyword">if</span> (/* 异步操作成功 */) &#123;</span><br><span class="line">        resolve ()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">myPromise.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">    // success</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">    // failure</span><br><span class="line">&#125;)</span><br><span class="line">..catch(error =&gt; &#123;···&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="4、async、await"><a href="#4、async、await" class="headerlink" title="4、async、await"></a>4、async、await</h4><pre><code>函数前面多了一个async关键字, 返回一个 Promise 对象, 可以使用then方法添加回调函数。
await关键字只能在async函数内使用, await后面跟着的应该是一个Promise, 如果不是 Promise 对象，就直接返回对应的值。
</code></pre><p><strong>async和promise的区别：</strong><br>    1、async的代码更像同步, 代码比promise更简洁<br>    2、依赖关系多的话, promise会链式调用then, 代码不够简洁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> myPromise (num) &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise(<span class="keyword">function</span>(resolve, reject)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; 8) &#123;</span><br><span class="line">            resolve <span class="string">'大于'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject <span class="string">'小于'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// Promise</span><br><span class="line"><span class="keyword">function</span> getNum (num) &#123;</span><br><span class="line">    <span class="built_in">return</span> Promise.resolve(num)</span><br><span class="line">&#125;</span><br><span class="line">getNum(9).<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> myPromise(data)</span><br><span class="line">&#125;).<span class="keyword">then</span>(data =&gt; &#123;console.log(data) // 大于&#125;)</span><br><span class="line"></span><br><span class="line">// Async</span><br><span class="line">async <span class="keyword">function</span> getNum (num) &#123;</span><br><span class="line">    <span class="built_in">let</span> result = await myPromise(num)</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">getNum(7).<span class="keyword">then</span>(data =&gt; &#123;console.log(data)&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="5、Set、Map数据结构"><a href="#5、Set、Map数据结构" class="headerlink" title="5、Set、Map数据结构"></a>5、Set、Map数据结构</h4><pre><code>Set: 类似数组, 没有重复的值。使用方法add(), delete(), has(), clear(), size
Map: 类似对象, 键值对的集合, 各种类型的值（包括对象）都可以当作键。使用方法set(), get(), delete(), has(), clear(), size
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Set</span><br><span class="line">const s = new Set();</span><br><span class="line">s.add([1,2,3]);</span><br><span class="line">s.add(&#123;age: 5&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of s) &#123;</span><br><span class="line">    console.log(i); // [1,2,3], &#123;age: 5&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> arr = [...s]; // [[1,2,3], &#123;age: 5&#125;]</span><br><span class="line">// Map</span><br><span class="line">const m = new Map()</span><br><span class="line">const o = &#123;p: <span class="string">'Hello World'</span>&#125;;</span><br><span class="line">const o2 = <span class="string">'职位'</span>;</span><br><span class="line">m.set(o, <span class="string">'打招呼'</span>);</span><br><span class="line">m.set(<span class="string">'o2'</span>, o2); </span><br><span class="line">m.get(<span class="string">'o2'</span>); // 职位</span><br><span class="line">m.get(o); // 打招呼</span><br></pre></td></tr></table></figure>
<h4 id="6、为什么会有es6"><a href="#6、为什么会有es6" class="headerlink" title="6、为什么会有es6"></a>6、为什么会有es6</h4><pre><code>对es5的不足进行补充, 添加新特性
</code></pre><h4 id="7、promise的原理是什么-手写一个promise"><a href="#7、promise的原理是什么-手写一个promise" class="headerlink" title="7、promise的原理是什么, 手写一个promise"></a>7、promise的原理是什么, 手写一个promise</h4><pre><code>Promise有pedding、fulfilled、rejected 3种状态, 可以从pedding转fulfilled, 也可以从pedding转rejected, 且状态不可逆,  fulfilled、rejected之间不能相互转换
</code></pre><h2 id="四、css、html相关"><a href="#四、css、html相关" class="headerlink" title="四、css、html相关"></a>四、css、html相关</h2><h4 id="1、什么是盒模型-IE盒模型和标准盒模型的区别"><a href="#1、什么是盒模型-IE盒模型和标准盒模型的区别" class="headerlink" title="1、什么是盒模型, IE盒模型和标准盒模型的区别"></a>1、什么是盒模型, IE盒模型和标准盒模型的区别</h4><pre><code>盒模型：元素的外边距（margin）、边框（border）、内边距（padding）、内容（content）组成。
IE模型：width / height = content + padding + border
标准盒模型：width / height = content
box-sizing: content-box(默认标准盒模型) | border-box(IE盒模型) | inherit
</code></pre><h4 id="2、什么是html语义化"><a href="#2、什么是html语义化" class="headerlink" title="2、什么是html语义化"></a>2、什么是html语义化</h4><pre><code>根据内容的结构化, 选择合适的标签, 便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。
</code></pre><h4 id="3、position定位属性有哪些-都是相对什么定位"><a href="#3、position定位属性有哪些-都是相对什么定位" class="headerlink" title="3、position定位属性有哪些, 都是相对什么定位"></a>3、position定位属性有哪些, 都是相对什么定位</h4><pre><code>relative：相对于本身的位置
absolute：相对于一个有position属性的父元素
fixed：相对于浏览器的窗口
static：会按照正常的文档流进行排列
</code></pre><h4 id="4、一个元素水平垂直居中-有哪些方法"><a href="#4、一个元素水平垂直居中-有哪些方法" class="headerlink" title="4、一个元素水平垂直居中 有哪些方法"></a>4、一个元素水平垂直居中 有哪些方法</h4><pre><code>方法一：使用flex
    display: flex;
    align-items: center;
    justify-content: center; 或者 text-align: center;
方法二：使用flex
    父元素——display: flex;
    子元素——margin: auto;
方法三：使用position(未知宽高), 设置父元素为相对定位，给子元素设置绝对定位
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translateX(-50%) translateY(-50%);
</code></pre><h4 id="5、主流浏览器有哪些兼容性问题"><a href="#5、主流浏览器有哪些兼容性问题" class="headerlink" title="5、主流浏览器有哪些兼容性问题"></a>5、主流浏览器有哪些兼容性问题</h4><pre><code>1、某些标签默认的padding和margin不同
解决：设置* {margin: 0, padding: 0}
</code></pre><h4 id="6、标签的套嵌规则"><a href="#6、标签的套嵌规则" class="headerlink" title="6、标签的套嵌规则"></a>6、标签的套嵌规则</h4><pre><code>1、块级元素可以包含行内元素或某些块元素; 但行内元素却不能包含块元素, 它只能包含其它的行内元素
2、块级元素不能放在&lt;p&gt;里面
参考文献[百度](https://blog.csdn.net/yyl927117/article/details/70230044 &quot;标签的嵌套规则&quot;)
</code></pre><h4 id="7、display有哪些属性"><a href="#7、display有哪些属性" class="headerlink" title="7、display有哪些属性"></a>7、display有哪些属性</h4><pre><code>常用：inline、inline-block、flex、table、grid
不常用：table-column、table-cell、table-row、table-row-group、table-column-group、table-header-group、table-footer-group
</code></pre><h4 id="8、浏览器端的渲染机制"><a href="#8、浏览器端的渲染机制" class="headerlink" title="8、浏览器端的渲染机制"></a>8、浏览器端的渲染机制</h4><h4 id="9、css的权值-css引入方式"><a href="#9、css的权值-css引入方式" class="headerlink" title="9、css的权值, css引入方式"></a>9、css的权值, css引入方式</h4><pre><code>权值：!important &gt; style(1000) &gt; id(100) &gt; class(10) &gt; 标签(1)
引用方式：
1、行内样式
    &lt;h1 style=&quot;color:red;&quot;&gt;style属性的应用&lt;/h1&gt;
2、内部样式style标签
    &lt;head&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            h3{
                    color:red;
                }
        &lt;/style&gt;
    &lt;/head&gt;
3、外部引入
    &lt;link type=&quot;text/css&quot; rel=&quot;styleSheet&quot;  href=&quot;CSS文件路径&quot; /&gt;
    &lt;style type=&quot;text/css&quot;&gt;
        @import url(&quot;css文件路径&quot;);
    &lt;/style&gt;
优先级：行内样式 &gt; 内部样式 &gt; 外部引入
</code></pre><h4 id="10、html有哪些空标签"><a href="#10、html有哪些空标签" class="headerlink" title="10、html有哪些空标签"></a>10、html有哪些空标签</h4><pre><code>没有闭合的标签称为空标签
如: &lt;img /&gt;  &lt;hr /&gt;  &lt;br /&gt;  &lt;input /&gt; &lt;meta /&gt; &lt;link /&gt;等
</code></pre><h4 id="11、h5有哪些"><a href="#11、h5有哪些" class="headerlink" title="11、h5有哪些"></a>11、h5有哪些</h4><p><strong>注： HTML5是HTML的第五个版本</strong><br>    <strong>html5 ≈ html + css3 + js + api</strong><br>    新增了一些标签、表单控件、样式选择器、伪类、表单校验<br>    localstorage、sessionStorage、离线存储<br>    map、地理位置<br>    canvas<br>    音频、视频<br>    Web SQL 数据库<br>    动画<br>    WebSocket<br>    拖拽</p>
<h4 id="12、html和xhtml的区别"><a href="#12、html和xhtml的区别" class="headerlink" title="12、html和xhtml的区别"></a>12、html和xhtml的区别</h4><pre><code>xhtml语法更严格
a、元素语法
    XHTML 元素必须正确嵌套
    XHTML 元素必须始终关闭
    XHTML 元素必须小写
    XHTML 文档必须有一个根元素
b、属性语法
    XHTML 属性必须使用小写
    XHTML 属性值必须用引号包围
    XHTML 属性简写也是禁止的 错误：&lt;input checked&gt; 正确：&lt;input checked=&apos;checked&apos;&gt;
</code></pre><h2 id="五、React框架相关"><a href="#五、React框架相关" class="headerlink" title="五、React框架相关"></a>五、React框架相关</h2><h4 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h4><h4 id="2、代码分割"><a href="#2、代码分割" class="headerlink" title="2、代码分割"></a>2、代码分割</h4><pre><code>方法一：react的新特性
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;lazy, Suspense&#125; from <span class="string">'react'</span></span><br><span class="line">const LayoutPage = lazy(() =&gt; import(/* webpackChunkName: <span class="string">'Layout'</span> */ <span class="string">'layout/index.jsx'</span>))</span><br><span class="line">const Layout = <span class="keyword">function</span> (props) &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">            &lt;LayoutPage /&gt;</span><br><span class="line">        &lt;/Suspense&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

方法二：react-loadable
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Loadable from <span class="string">'react-loadable'</span>        </span><br><span class="line">const LayoutPage = Loadable(&#123;</span><br><span class="line">    loader: () =&gt; import(/* webpackChunkName: <span class="string">'Layout'</span> */ <span class="string">'layout/index.jsx'</span>)),</span><br><span class="line">    loading: &lt;div&gt;Loading...&lt;/div&gt;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

方法三：自定义方法实现
</code></pre><h4 id="3、组件深度嵌套时-从顶层组件向最内层组件传递数据-使用新版-Context-API"><a href="#3、组件深度嵌套时-从顶层组件向最内层组件传递数据-使用新版-Context-API" class="headerlink" title="3、组件深度嵌套时, 从顶层组件向最内层组件传递数据, 使用新版 Context API"></a>3、组件深度嵌套时, 从顶层组件向最内层组件传递数据, 使用新版 Context API</h4><pre><code>a: React.createContext 方法用于创建一个 Context 对象。该对象包含 Provider 和 Consumer两个属性，分别为两个 React 组件。
b: Provider 组件。用在组件树中更外层的位置。它接受一个名为 value 的 prop，其值可以是任何 JavaScript 中的数据类型。
c: Consumer 组件。可以在 Provider 组件内部的任何一层使用。它接收一个名为 children 值为一个函数的 prop。这个函数的参数是 Provider 组件接收的那个 value prop 的值，返回值是一个 React 元素（一段 JSX 代码）。
</code></pre><h4 id="4、Hooks"><a href="#4、Hooks" class="headerlink" title="4、Hooks"></a>4、Hooks</h4><pre><code>函数式组件
</code></pre><h2 id="六、webpack打包相关"><a href="#六、webpack打包相关" class="headerlink" title="六、webpack打包相关"></a>六、webpack打包相关</h2><h4 id="1、打包原理"><a href="#1、打包原理" class="headerlink" title="1、打包原理"></a>1、打包原理</h4><h4 id="2、background引用图片和img引用图片的区别"><a href="#2、background引用图片和img引用图片的区别" class="headerlink" title="2、background引用图片和img引用图片的区别"></a>2、background引用图片和img引用图片的区别</h4><pre><code>当我们要引用一个图片时，在js文件中要以引用它的html的路径为准；而在css文件中，要以该css的路径为准
</code></pre><p>参考文献<a href="https://www.jianshu.com/p/794c5f301169" title="Webpack打包图片路径问题" target="_blank" rel="noopener">Webpack打包图片路径问题</a></p>
<h4 id="3、contentBase"><a href="#3、contentBase" class="headerlink" title="3、contentBase"></a>3、contentBase</h4><pre><code>安装了html-webpack-plugin后, 此参数可不需要。
作用: 给浏览器访问的页面(虚拟文件)指定根目录, 默认访问html页面, 若没有html页面, 则看到所有文件(类似静态资源服务器)
前提：输出路径是dest, webpack文件在根目录下, 没有html页面
当启动webpack-dev-server的时候, 会在内存中创建dest文件, 在浏览器中访问可以看到跟目录下的所有文件; 
若设置contentBase为a, 在浏览器中访问可以看到a目录下的所有文件；
若有html页面, 则默认访问html页面,看不到所有文件。
</code></pre><h4 id="4、loader和plugin的区别"><a href="#4、loader和plugin的区别" class="headerlink" title="4、loader和plugin的区别"></a>4、loader和plugin的区别</h4><pre><code>loader是一个转换器，可以对文件进行编译、压缩等处理
plugin是一个扩展器，是在loader结束后运行，基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务。
</code></pre><h4 id="5、file-loader-和-url-loader-的区别"><a href="#5、file-loader-和-url-loader-的区别" class="headerlink" title="5、file-loader 和 url-loader 的区别"></a>5、file-loader 和 url-loader 的区别</h4><pre><code>url-loader强大之处：
1.文件大小小于limit参数，url-loader将会把文件转为DataURL；
2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。
因此我们只需要安装url-loader即可
</code></pre><h2 id="七、算法"><a href="#七、算法" class="headerlink" title="七、算法"></a>七、算法</h2><h4 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h4><p>原理：对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小(降序)或最大(升序)的元素“浮”到顶端<br>对数子8、70、16、50、6、100、1进行排序<br>第一轮结果：8、16、50、6、70、1、100<br>第二轮结果：8、16、6、50、1、70、100<br>第三轮结果：8、16、6、1、50、70、100<br>第四轮结果：6、8、1、16、50、70、100<br>第五轮结果：6、1、8、16、50、70、100<br>第六轮结果：1、6、8、16、50、70、100<br>总结：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [8, 70, 16, 50, 6, 100, 1]</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i=0; i &lt; arr.length-1; i++) &#123;//外层循环控制排序趟数</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> j=0; j &lt; arr.length-1-i; j++) &#123;//内层循环控制每一趟排序多少次</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">            <span class="built_in">let</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+1];</span><br><span class="line">            arr[j+1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr) // 升序  [1, 6, 8, 16, 50, 70, 100]</span><br></pre></td></tr></table></figure></p>
<h2 id="八、网页安全"><a href="#八、网页安全" class="headerlink" title="八、网页安全"></a>八、网页安全</h2><h2 id="k、js题"><a href="#k、js题" class="headerlink" title="k、js题"></a>k、js题</h2><h4 id="1、数组去重"><a href="#1、数组去重" class="headerlink" title="1、数组去重"></a>1、数组去重</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,1,2,3,4]</span><br><span class="line">1、[...new Set(arr)];</span><br><span class="line">2、_.uniq(arr);</span><br><span class="line">3、var newArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArr.includes(i)) &#123;</span><br><span class="line">        newArr.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、字符串转number"><a href="#2、字符串转number" class="headerlink" title="2、字符串转number"></a>2、字符串转number</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">'12'</span></span><br><span class="line">1、parseInt(str)、parseFloat(str)</span><br><span class="line">2、Number(str)</span><br><span class="line">3、str - 0</span><br><span class="line">4、_.toNumber(str)</span><br></pre></td></tr></table></figure>
<h4 id="3、-‘1’-‘2’-‘3’-map-parseInt"><a href="#3、-‘1’-‘2’-‘3’-map-parseInt" class="headerlink" title="3、[‘1’, ‘2’, ‘3’].map(parseInt)"></a>3、[‘1’, ‘2’, ‘3’].map(parseInt)</h4><pre><code>结果为：[1, NaN, NaN]
解析:
parseInt最终将字符串转为十进制
parseInt(&apos;1&apos;, 0)   // 结果1。radix为0, 基数为十进制
parseInt(&apos;2&apos;, 1)   // 结果NaN。2&lt;radix&lt;36 
parseInt(&apos;3&apos;, 2)   // 结果NaN。radix为2, 二进制只有0，1
</code></pre><h4 id="4、-‘1’-‘2’-‘3’-filter-parseInt"><a href="#4、-‘1’-‘2’-‘3’-filter-parseInt" class="headerlink" title="4、[‘1’, ‘2’, ‘3’].filter(parseInt)"></a>4、[‘1’, ‘2’, ‘3’].filter(parseInt)</h4><pre><code>结果为：[&apos;1&apos;]
解析:
parseInt最终将字符串转为十进制
parseInt(&apos;1&apos;, 0)   // 结果1。return true
parseInt(&apos;2&apos;, 1)   // 结果NaN。return false
parseInt(&apos;3&apos;, 2)   // 结果NaN。return false
</code></pre><h4 id="5、输出结果-如何解决"><a href="#5、输出结果-如何解决" class="headerlink" title="5、输出结果, 如何解决"></a>5、输出结果, 如何解决</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i=0;i&lt;10;i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i) // 结果: 10个10</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i) // 结果: 0、1、2、3、4、5、6、7、8、9</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> _func = <span class="keyword">function</span> (i) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            console.log(i) // 结果: 0、1、2、3、4、5、6、7、8、9</span><br><span class="line">        &#125;, 0)</span><br><span class="line">    &#125;</span><br><span class="line">    _func(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(</span><br><span class="line">        <span class="keyword">function</span> timer(i) &#123;</span><br><span class="line">            console.log(i) // 结果: 0、1、2、3、4、5、6、7、8、9</span><br><span class="line">    &#125;, 0, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、数组拍平"><a href="#6、数组拍平" class="headerlink" title="6、数组拍平"></a>6、数组拍平</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, [3, 4, [5, 6]]]</span><br><span class="line"><span class="built_in">let</span> newArr = arr6.toString().split(<span class="string">','</span>).map(item =&gt; parseInt(item)) // [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> arr2 = [1, 2, [3, 4]]</span><br><span class="line"><span class="built_in">let</span> newArr2 = arr2.toString().split(<span class="string">','</span>).map(item =&gt; parseInt(item)) // [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> newArr3 = []</span><br><span class="line"><span class="keyword">function</span> flat(arr) &#123;</span><br><span class="line">    arr.map(<span class="keyword">function</span>(item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Array.isArray(item)) &#123;</span><br><span class="line">            flat(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newArr3.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">flat(arr); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<h4 id="7、把数组顺序打乱"><a href="#7、把数组顺序打乱" class="headerlink" title="7、把数组顺序打乱"></a>7、把数组顺序打乱</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"><span class="keyword">function</span> randomsort(a, b) &#123;</span><br><span class="line">    <span class="built_in">return</span> Math.random()&gt;.5 ? -1 : 1;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.sort(randomsort);</span><br></pre></td></tr></table></figure>
<h4 id="8、判断输出值"><a href="#8、判断输出值" class="headerlink" title="8、判断输出值"></a>8、判断输出值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">一、</span><br><span class="line">typeof typeof 1; // typeof 1 -&gt; <span class="string">'number'</span>; typeof <span class="string">'number'</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof <span class="string">'12dfd'</span>; //  typeof <span class="string">'12dfd'</span> -&gt; <span class="string">'string'</span>; typeof <span class="string">'string'</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof <span class="literal">true</span>; // typeof <span class="literal">true</span> -&gt; <span class="string">"boolean"</span>; typeof <span class="string">"boolean"</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof null; // typeof null -&gt; <span class="string">"object"</span>; typeof <span class="string">"object"</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof undefined; // typeof undefined -&gt; <span class="string">"undefined"</span>; typeof <span class="string">"undefined"</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof [1,2,3]; // typeof [1,2,3] -&gt; <span class="string">"object"</span>; typeof <span class="string">"object"</span> -&gt; <span class="string">"string"</span></span><br><span class="line">typeof typeof &#123;&#125;; // typeof &#123;&#125; -&gt; <span class="string">"object"</span>; typeof <span class="string">"object"</span> -&gt; <span class="string">"string"</span></span><br><span class="line"></span><br><span class="line">二、</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var a = b = 5;</span><br><span class="line">&#125;())</span><br><span class="line">console.log(a); // 报错</span><br><span class="line">console.log(b); // 5</span><br><span class="line">解析：变量b没有用var声明, 所以是全局的, 挂载在window上; 变量a用var声明了, 是私有变量, 只能在函数中获取</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var a = b = 5;</span><br><span class="line">    console.log(a); // 5</span><br><span class="line">    console.log(b); // 5</span><br><span class="line">&#125;())</span><br><span class="line">解析：变量b没有用var声明, 是全局的; 变量a用var声明了, 是私有变量; 函数内可以访问外部的变量</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/10/问题总结/" data-id="ckbbm4jjk000j88uvoylodkab" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/30/微信公众号/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          微信公众号
        
      </div>
    </a>
  
  
    <a href="/2019/09/29/搭建静态服务器/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">搭建静态服务器</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/12/开机自启动脚本/">开机自启动脚本</a>
          </li>
        
          <li>
            <a href="/2020/06/08/taro小程序/">taro小程序</a>
          </li>
        
          <li>
            <a href="/2020/06/03/javascript页面容错处理/">javascript页面容错处理</a>
          </li>
        
          <li>
            <a href="/2020/05/22/web网页安全/">web网页安全</a>
          </li>
        
          <li>
            <a href="/2020/05/22/http/">http</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Candy<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>